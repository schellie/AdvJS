//C  ADVENTURES
//
//C  CURRENT LIMITS:
//C	9650 WORDS OF MESSAGE TEXT (LINES, LINSIZ) .
var LINSIZ  = 9650;
var LINES 	= new Array();

//C	750 TRAVEL OPTIONS (TRAVEL, TRVSIZ) .
var TRVSIZ  = 750;
var TRAVEL 	= new Array();

//C	300 VOCABULARY WORDS (KTAB, ATAB, TABSIZ) .
var TABSIZ  = 300;
var KTAB 	= new Array();
var ATAB 	= new Array();

//C	150 LOCATIONS (LTEXT, STEXT, KEY, COND, ABB, ATLOC, LOCSIZ) .
var LOCSIZ  = 150;	
var LTEXT 	= new Array();
var STEXT 	= new Array();
var KEY 	= new Array();
var COND 	= new Array();
var ABB 	= new Array();  
var ATLOC 	= new Array();

//C	100 OBJECTS (PLAC, PLACE, FIXD, FIXED, LINK (TWICE) , PTEXT, PROP) .
//DIMENSION LINK[200]
var OBJSIZ  = 100;	
var PLAC 	= new Array();
var PLACE 	= new Array();
var FIXD 	= new Array();
var FIXED 	= new Array();
var LINK 	= new Array();
var PTEXT 	= new Array();
var PROP 	= new Array();
var MAXTRS  = 79; // TREASURES ARE OBJECTS 50 THROUGH MAXTRS (CURRENTLY 79)
var TALLY   = 0;  // TALLY KEEPS TRACK OF HOW MANY ARE NOT YET FOUND
var TALLY2  = 0;  // TALLY2 COUNTS HOW MANY CAN NEVER BE FOUND (E.G. IF LOST BIRD OR BRIDGE)

//C	 35 "ACTION" VERBS (ACTSPK, VRBSIZ) .
var VRBSIZ  = 35;
var ACTSPK 	= new Array();

//C	205 RANDOM MESSAGES (RTEXT, RTXSIZ) .
var RTXSIZ  = 205;
var RTEXT 	= new Array();

//C	 12 DIFFERENT PLAYER CLASSIFICATIONS (CTEXT, CVAL, CLSMAX) .
var CLSMAX  = 12;
var CTEXT 	= new Array();
var CVAL 	= new Array();

//C	 20 HINTS, LESS 3 (HINTLC, HINTED, HINTS, HNTSIZ) .
//DIMENSION HINTS[20,4]
var HNTSIZ  = 20;
var HINTLC 	= new Array();
var HINTED 	= new Array();
var HINTS   = new Array();
while (HINTS.push([]) < 20); // make 20 lines
var HNTMAX  = 0; 

//C	 35 MAGIC MESSAGES (MTEXT, MAGSIZ) .
//var MAGSIZ  = 35;
//var MTEXT	= new Array();

//DIMENSION DSEEN[6],DLOC[6],ODLOC[6],HNAME[4]
var DSEEN 	= new Array();
var DLOC 	= new Array();
var ODLOC 	= new Array();
var DFLAG   = 0;
var DALTLC  = 18;
var CHLOC   = 114;
var CHLOC2  = 140;

// MNEMONICS
var KEYS, LAMP, GRATE, CAGE, ROD, ROD2, STEPS, BIRD, DOOR, PILLOW, SNAKE;
var FISSUR, TABLET, CLAM, OYSTER, MAGZIN, DWARF, KNIFE, FOOD, BOTTLE;
var WATER, OIL, PLANT, PLANT2, AXE, MIRROR, DRAGON, CHASM, TROLL, TROLL2;
var BEAR, MESSAG, VEND, BATTER, NUGGET, COINS, CHEST, EGGS, TRIDNT, VASE;
var EMRALD, PYRAM, PEARL, RUG, CHAIN, SPICES, BACK, LOOK, CAVE, ENTRNC;
var DPRSSN, ENTER, VERBSAY, LOCK, THROW, FIND, INVENT;

// Global variables
var WZDARK; // SAYS WHETHER THE LOC HE'S LEAVING WAS DARK
var LMWARN; // SAYS WHETHER HE'S BEEN WARNED ABOUT LAMP GOING DIM
var CLOSNG; // SAYS WHETHER ITS CLOSING TIME YET
var PANIC; // SAYS WHETHER HE'S FOUND OUT HE'S TRAPPED IN THE CAVE
var CLOSED; // SAYS WHETHER WE'RE ALL THE WAY CLOSED
var GAVEUP; // SAYS WHETHER HE EXITED VIA "QUIT"
var SCORNG; // SCORNG INDICATES TO THE SCORE ROUTINE WHETHER WE'RE DOING A "SCORE" COMMAND
var DEMO; // TRUE IF THIS IS A PRIME-TIME DEMONSTRATION GAME
var YEA; // RANDOM YES/NO REPLY

// OTHER RANDOM FLAGS AND COUNTERS, AS FOLLOWS:
var TURNS; // TALLIES HOW MANY COMMANDS HE'S GIVEN (IGNORES YES/NO) 
var LIMIT; // LIFETIME OF LAMP (NOT SET HERE) 
var IWEST; // HOW MANY TIMES HE'S SAID "WEST" INSTEAD OF "W"
var KNFLOC; // 0 IF NO KNIFE HERE, LOC IF KNIFE HERE, -1 AFTER CAVEAT
var DETAIL; // HOW OFTEN WE'VE SAID "NOT ALLOWED TO GIVE MORE DETAIL"
var ABBNUM; // HOW OFTEN WE SHOULD PRINT NON-ABBREVIATED DESCRIPTIONS
var MAXDIE; // NUMBER OF REINCARNATION MESSAGES AVAILABLE (UP TO 5) 
var NUMDIE; // NUMBER OF TIMES KILLED SO FAR
var HOLDNG; // NUMBER OF OBJECTS BEING CARRIED
var DKILL; // NUMBER OF DWARVES KILLED (UNUSED IN SCORING, NEEDED FOR MSG) 
var FOOBAR; // CURRENT PROGRESS IN SAYING "FEE FIE FOE FOO".
var BONUS; // USED TO DETERMINE AMOUNT OF BONUS IF HE REACHES CLOSING
var CLOCK1; // NUMBER OF TURNS FROM FINDING LAST TREASURE TILL CLOSING
var CLOCK2; // NUMBER OF TURNS FROM FIRST WARNING TILL BLINDING FLASH

//DATA SETUP/0/,BLKLIN/ true/
var SETUP = 0; // not useful??
var BLKLIN = true;
var LOC;
var NEWLOC;
var OLDLOC;
var OLDLC2;
var VERB;
var OBJ;
var WD1;
var WD2;
var IDONDX;
var MXSCOR;
var SCORE;
var CLSSES;

var HOLDNG;

//used for magic ...
var WKDAY;
var WKEND;
var HOLID;
var HBEGIN;
var HEND;
var HNAME	= new Array();
var SHORT;
var MAGIC;
var MAGNM;
//... until here
var LATNCY;
var SAVED;
var SAVET;
var YES;
var START;

// STATEMENT FUNCTIONS

// TRUE IF THE OBJ IS BEING CARRIED
function TOTING(obj) {
	return PLACE[obj] == -1;
}

// TRUE IF THE OBJ IS AT "LOC" (OR IS BEING CARRIED)
function HERE(obj) {
	return PLACE[obj] == LOC || TOTING(obj);
}

// TRUE IF ON EITHER SIDE OF TWO-PLACED OBJECT
function AT(obj) {
	return PLACE[obj] == LOC || FIXED[obj] == LOC;
}

function LIQ2(pbotl) { /** test ok **/
	return (1-pbotl)*WATER + (pbotl/2>>0)*(WATER+OIL);
}

// OBJECT NUMBER OF LIQUID IN BOTTLE
function LIQ() { /** test ok **/
	return LIQ2(Math.max(PROP[BOTTLE], -1-PROP[BOTTLE]));
}

// OBJECT NUMBER OF LIQUID (IF ANY) AT LOC
function LIQLOC(loc) { /** test ok **/
	var c1 = (COND[loc]/2>>0)*2,
		c2 = (COND[loc]/4>>0);
	return LIQ2(((c1%8)-5) * (c2%2) + 1);
}

// TRUE IF COND(L) HAS BIT N SET (BIT 0 IS UNITS BIT)
function BITSET(l, n) {
	return ((COND[L] & 1<<n) != 0);
}

// TRUE IF LOC MOVES WITHOUT ASKING FOR INPUT (COND=2)
function FORCED(loc) { /** test ok **/
	return (COND[LOC] == 2);
}

// TRUE IF LOCATION "LOC" IS DARK
function DARK() { /** test ok **/
	return ((COND[LOC] % 2) == 0) && ((PROP[LAMP] == 0) || !HERE(LAMP));
}

// TRUE N% OF THE TIME (N INTEGER FROM 0 TO 100)
function PCT(n) { /** test ok **/
	return (RAN(100) < n);
}



	
//I/O for html/js
var isTouch = (('ontouchstart' in window) || (navigator.msMaxTouchPoints > 0)); // touch device?
var displayText; // area to output messages
var commandLine; // area to input commands

//Display a string 
function out(s) { /** test ok **/
	var displayText;
	displayText = document.getElementById('displayText');
	displayText.value += s + '\n';
	displayText.scrollTop = displayText.scrollHeight;
}

//Update the status bar
function updateStatusBar(score, moves) { /** test ok **/
	document.getElementById('statusScore').innerHTML = score;
	document.getElementById('statusMoves').innerHTML = moves;
}

//Give focus to commandLine if not a touch device. 
function giveCommandFocus() { /** test ok **/
    if (!isTouch) commandLine.focus();
}

//Get command.
function getCommand() { /** test ok **/
    var text = commandLine.value;
    commandLine.value = '';
    out('\n' + '> ' + text);
    //processCommand(text);
    giveCommandFocus();
}

function processCommand(text){
	 parseInput(text);
	 processInput();

	 if (normalInput) processEvents();
	 updateStatusBar(SCORE, TURNS);
}

//C  DESCRIPTION OF THE DATABASE FORMAT
//C
//C
//C  THE DATA FILE CONTAINS SEVERAL SECTIONS.  EACH BEGINS WITH A LINE CONTAINING
//C  A NUMBER IDENTIFYING THE SECTION, AND ENDS WITH A LINE CONTAINING "-1".
//C
//C  SECTION 1: LONG FORM DESCRIPTIONS.  EACH LINE CONTAINS A LOCATION NUMBER,
//C	A TAB, AND A LINE OF TEXT.  THE SET OF (NECESSARILY ADJACENT)  LINES
//C	WHOSE NUMBERS ARE X FORM THE LONG DESCRIPTION OF LOCATION X.
//C  SECTION 2: SHORT FORM DESCRIPTIONS.  SAME FORMAT AS LONG FORM.  NOT ALL
//C	PLACES HAVE SHORT DESCRIPTIONS.
//C  SECTION 3: TRAVEL TABLE.  EACH LINE CONTAINS A LOCATION NUMBER (X) , A SECOND
//C	LOCATION NUMBER (Y) , AND A LIST OF MOTION NUMBERS (SEE SECTION 4) .
//C	EACH MOTION REPRESENTS A VERB WHICH WILL GO TO Y IF CURRENTLY AT X.
//C	Y, IN TURN, IS INTERPRETED AS FOLLOWS.  LET M = Y/1000, N = Y MOD 1000.
//C		IF N<= 300	IT IS THE LOCATION TO GO TO.
//C		IF 300<N<= 500	N-300 IS USED IN A COMPUTED GOTO TO
//C					A SECTION OF SPECIAL CODE.
//C		IF N>500	MESSAGE N-500 FROM SECTION 6 IS PRINTED,
//C					AND HE STAYS WHEREVER HE IS.
//C	MEANWHILE, M SPECIFIES THE CONDITIONS ON THE MOTION.
//C		IF M = 0		IT'S UNCONDITIONAL.
//C		IF 0<M<100	IT IS DONE WITH M% PROBABILITY.
//C		IF M = 100	UNCONDITIONAL, BUT FORBIDDEN TO DWARVES.
//C		IF 100<M<= 200	HE MUST BE CARRYING OBJECT M-100.
//C		IF 200<M<= 300	MUST BE CARRYING OR IN SAME ROOM AS M-200.
//C		IF 300<M<= 400	PROP[M MOD 100] MUST *NOT* BE 0.
//C		IF 400<M<= 500	PROP[M MOD 100] MUST *NOT* BE 1.
//C		IF 500<M<= 600	PROP[M MOD 100] MUST *NOT* BE 2, ETC.
//C	IF THE CONDITION (IF ANY)  IS NOT MET, THEN THE NEXT *DIFFERENT*
//C	"DESTINATION" VALUE IS USED (UNLESS IT FAILS TO MEET *ITS* CONDITIONS,
//C	IN WHICH CASE THE NEXT IS FOUND, ETC.) .  TYPICALLY, THE NEXT DEST WILL
//C	BE FOR ONE OF THE SAME VERBS, SO THAT ITS ONLY USE IS AS THE ALTERNATE
//C	DESTINATION FOR THOSE VERBS.  FOR INSTANCE:
//C		15	110022	29	31	34	35	23	43
//C		15	14	29
//C	THIS SAYS THAT, FROM LOC 15, ANY OF THE VERBS 29, 31, ETC., WILL TAKE
//C	HIM TO 22 IF HE'S CARRYING OBJECT 10, AND OTHERWISE WILL GO TO 14.
//C		11	303008	49
//C		11	9	50
//C	THIS SAYS THAT, FROM 11, 49 TAKES HIM TO 8 UNLESS PROP[3] = 0, IN WHICH
//C	CASE HE GOES TO 9.  VERB 50 TAKES HIM TO 9 REGARDLESS OF PROP[3].
//C  SECTION 4: VOCABULARY.  EACH LINE CONTAINS A NUMBER (N) , A TAB, AND A
//C	FIVE-LETTER WORD.  CALL M = N/1000.  IF M = 0, THEN THE WORD IS A MOTION
//C	VERB FOR USE IN TRAVELLING (SEE SECTION 3) .  ELSE, IF M = 1, THE WORD IS
//C	AN OBJECT.  ELSE, IF M = 2, THE WORD IS AN ACTION VERB (SUCH AS "CARRY"
//C	OR "ATTACK") .  ELSE, IF M = 3, THE WORD IS A SPECIAL CASE VERB (SUCH AS
//C	"DIG")  AND N MOD 1000 IS AN INDEX INTO SECTION 6.  OBJECTS FROM 50 TO
//C	(CURRENTLY, ANYWAY)  79 ARE CONSIDERED TREASURES (FOR PIRATE, CLOSEOUT) .
//C  SECTION 5: OBJECT DESCRIPTIONS.  EACH LINE CONTAINS A NUMBER (N) , A TAB,
//C	AND A MESSAGE.  IF N IS FROM 1 TO 100, THE MESSAGE IS THE "INVENTORY"
//C	MESSAGE FOR OBJECT N.  OTHERWISE, N SHOULD BE 000, 100, 200, ETC., AND
//C	THE MESSAGE SHOULD BE THE DESCRIPTION OF THE PRECEDING OBJECT WHEN ITS
//C	PROP VALUE IS N/100.  THE N/100 IS USED ONLY TO DISTINGUISH MULTIPLE
//C	MESSAGES FROM MULTI-LINE MESSAGES; THE PROP INFO ACTUALLY REQUIRES ALL
//C	MESSAGES FOR AN OBJECT TO BE PRESENT AND CONSECUTIVE.  PROPERTIES WHICH
//C	PRODUCE NO MESSAGE SHOULD BE GIVEN THE MESSAGE ">$<".
//C  SECTION 6: ARBITRARY MESSAGES.  SAME FORMAT AS SECTIONS 1, 2, AND 5, EXCEPT
//C	THE NUMBERS BEAR NO RELATION TO ANYTHING (EXCEPT FOR SPECIAL VERBS
//C	IN SECTION 4) .
//C  SECTION 7: OBJECT LOCATIONS.  EACH LINE CONTAINS AN OBJECT NUMBER AND ITS
//C	INITIAL LOCATION (ZERO (OR OMITTED)  IF NONE) .  IF THE OBJECT IS
//C	IMMOVABLE, THE LOCATION IS FOLLOWED BY A "-1".  IF IT HAS TWO LOCATIONS
//C	(E.G. THE GRATE)  THE FIRST LOCATION IS FOLLOWED WITH THE SECOND, AND
//C	THE OBJECT IS ASSUMED TO BE IMMOVABLE.
//C  SECTION 8: ACTION DEFAULTS.  EACH LINE CONTAINS AN "ACTION-VERB" NUMBER AND
//C	THE INDEX (IN SECTION 6)  OF THE DEFAULT MESSAGE FOR THE VERB.
//C  SECTION 9: LIQUID ASSETS, ETC.  EACH LINE CONTAINS A NUMBER (N)  AND UP TO 20
//C	LOCATION NUMBERS.  BIT N (WHERE 0 IS THE UNITS BIT)  IS SET IN COND[LOC]
//C	FOR EACH LOC GIVEN.  THE COND BITS CURRENTLY ASSIGNED ARE:
//C		0	LIGHT
//C		1	IF BIT 2 IS ON: ON FOR OIL, OFF FOR WATER
//C		2	LIQUID ASSET, SEE BIT 1
//C		3	PIRATE DOESN'T GO HERE UNLESS FOLLOWING PLAYER
//C	OTHER BITS ARE USED TO INDICATE AREAS OF INTEREST TO "HINT" ROUTINES:
//C		4	TRYING TO GET INTO CAVE
//C		5	TRYING TO CATCH BIRD
//C		6	TRYING TO DEAL WITH SNAKE
//C		7	LOST IN MAZE
//C		8	PONDERING DARK ROOM
//C		9	AT WITT'S END
//C	COND[LOC] IS SET TO 2, OVERRIDING ALL OTHER BITS, IF LOC HAS FORCED
//C	MOTION.
//C  SECTION 10: CLASS MESSAGES.  EACH LINE CONTAINS A NUMBER (N) , A TAB, AND A
//C	MESSAGE DESCRIBING A CLASSIFICATION OF PLAYER.  THE SCORING SECTION
//C	SELECTS THE APPROPRIATE MESSAGE, WHERE EACH MESSAGE IS CONSIDERED TO
//C	APPLY TO PLAYERS WHOSE SCORES ARE HIGHER THAN THE PREVIOUS N BUT NOT
//C	HIGHER THAN THIS N.  NOTE THAT THESE SCORES PROBABLY CHANGE WITH EVERY
//C	MODIFICATION (AND PARTICULARLY EXPANSION)  OF THE PROGRAM.
//C  SECTION 11: HINTS.  EACH LINE CONTAINS A HINT NUMBER (CORRESPONDING TO A
//C	COND BIT, SEE SECTION 9) , THE NUMBER OF TURNS HE MUST BE AT THE RIGHT
//C	LOC(S)  BEFORE TRIGGERING THE HINT, THE POINTS DEDUCTED FOR TAKING THE
//C	HINT, THE MESSAGE NUMBER (SECTION 6)  OF THE QUESTION, AND THE MESSAGE
//C	NUMBER OF THE HINT.  THESE VALUES ARE STASHED IN THE "HINTS" ARRAY.
//C	HNTMAX IS SET TO THE MAX HINT NUMBER (<=  HNTSIZ) .  NUMBERS 1-3 ARE
//C	UNUSABLE SINCE COND BITS ARE OTHERWISE ASSIGNED, SO 2 IS USED TO
//C	REMEMBER IF HE'S READ THE CLUE IN THE REPOSITORY, AND 3 IS USED TO
//C	REMEMBER WHETHER HE ASKED FOR INSTRUCTIONS (GETS MORE TURNS, BUT LOSES
//C	POINTS) .
//C  SECTION 12: MAGIC MESSAGES. IDENTICAL TO SECTION 6 EXCEPT PUT IN A SEPARATE
//C	SECTION FOR EASIER REFERENCE.  MAGIC MESSAGES ARE USED BY THE STARTUP,
//C	MAINTENANCE MODE, AND RELATED ROUTINES.
//C  SECTION 0: END OF DATABASE.
//C  READ THE DATABASE IF WE HAVE NOT YET DONE SO
//
//	if (SETUP != 0) GOTO 1100
//	TYPE 1000
//	1000	FORMAT(' Initializing...') 
//
// CLEAR OUT THE VARIOUS TEXT-POINTER ARRAYS.  ALL TEXT IS STORED IN ARRAY
// LINES; EACH LINE IS PRECEDED BY A WORD POINTING TO THE NEXT POINTER (I.E.
// THE WORD FOLLOWING THE END OF THE LINE) .  THE POINTER IS NEGATIVE IF THIS IS
// FIRST LINE OF A MESSAGE.  THE TEXT-POINTER ARRAYS CONTAIN INDICES OF
// POINTER-WORDS IN LINES.  STEXT[N] IS SHORT DESCRIPTION OF LOCATION N.
// LTEXT[N] IS LONG DESCRIPTION.  PTEXT[N] POINTS TO MESSAGE FOR PROP[N] = 0.
// SUCCESSIVE PROP MESSAGES ARE FOUND BY CHASING POINTERS.  RTEXT CONTAINS
// SECTION 6'S STUFF.  CTEXT[N] POINTS TO A PLAYER-CLASS MESSAGE.  MTEXT IS FOR
// SECTION 12.  WE ALSO CLEAR COND.  SEE DESCRIPTION OF SECTION 9 FOR DETAILS.
//

function setup() {
	
	var sections = new Array();
	var OLDLOC = -1;

	// setup I/O
    commandLine = document.getElementById("commandLine");
    // Command line listener
    commandLine.onkeypress = function(event) {
        if (event.keyCode == 13) getCommand();
    };
    displayText = document.getElementById('displayText');
    
    out('Initializing...');
    
	// Init tables
	for (var i = 1; i <= 300; i++) {
		if (i <= OBJSIZ) PTEXT[i] = 0;
		if (i <= RTXSIZ) RTEXT[i] = 0;
		if (i <= CLSMAX) CTEXT[i] = 0;
		// if (i <= MAGSIZ) MTEXT[i] = 0;
		if (i <= LOCSIZ) {
			STEXT[i] = 0;
			LTEXT[i] = 0;
			KEY[i] = 0;
			COND[i] = 0;
		};
	};		
	// Line always starts with a number, rest of text starts at position 8
	LINES = readData(); // Store all data in the LINES array
	// scan for sections
	for (var i = 1; i < LINES.length; i++) {
		LOC = parseInt(LINES[i]);
        if (OLDLOC == -1) sections[LOC] = i;
        OLDLOC = LOC;
	};

	// Section 1
	parseText(sections[1], LTEXT);
	// Section 2
	parseText(sections[2], STEXT);
	// Section 5
	parseText(sections[5], PTEXT, true);
	// Section 6
	parseText(sections[6], RTEXT);
	// Section 10
	parseText(sections[10], LTEXT);
	// Section 3
	parseTravel(sections[3]);
	// Section 4
	parseVocab(sections[4]);
	// Section 7
	initObj(sections[7]);
	// Section 8
	defMssg(sections[8]);
	// Section 9
	initCond(sections[9]);
	// Section 11
	initHint(sections[11]);
	
	// FINISH CONSTRUCTING INTERNAL DATA FORMAT
	setupFixedMotion();
	setupAtLoc();
	setupTreasures();
	clearHintStuff();
	defineMnemonics();
	initDwarves();
	initGlobals();
	// FINALLY, SINCE WE'RE CLEARLY SETTING THINGS UP FOR THE FIRST TIME...
	POOF();

    out('INIT Done');
}

// SECTIONS 1, 2, 5, 6, 10, 12.  READ MESSAGES AND SET UP POINTERS.
function parseText(ndx, array, condition) {
	var loc, 
		oldloc = 0, 
    condition = typeof condition !== 'undefined' ? condition : false;
	while (++ndx, loc = parseInt(LINES[ndx]), loc != -1) {
		if (loc != oldloc) {
			oldloc = loc;
			if (!condition || (loc > 0 && loc < 100)) array[loc] = ndx;
		}
	}
}

// THE STUFF FOR SECTION 3 IS ENCODED HERE.  EACH "FROM-LOCATION" GETS A
// CONTIGUOUS SECTION OF THE "TRAVEL" ARRAY.  EACH ENTRY IN TRAVEL IS
// NEWLOC*1000 + KEYWORD (FROM SECTION 4, MOTION VERBS) , AND IS NEGATED IF
// THIS IS THE LAST ENTRY FOR THIS LOCATION.  KEY[N] IS THE INDEX IN TRAVEL
// OF THE FIRST OPTION AT LOCATION N.
function parseTravel(ndx) {
	var tk = new Array(),
		loc, 
		newloc = 0, 
		trvs = 1;
	while (++ndx, tk = LINES[ndx].split(/[ ]+/).map(Number), loc = tk.shift(), loc != -1) {
		newloc = tk.shift();
		if (KEY[loc] == 0) KEY[loc] = trvs;
		else TRAVEL[trvs-1] = -TRAVEL[trvs-1];
		for (var t in tk) {
			if (tk[t] != 0) {
				TRAVEL[trvs] = newloc * 1000 + tk[t];
				trvs++;
			}
		}
		TRAVEL[trvs-1] = -TRAVEL[trvs-1];
	}
}

// HERE WE READ IN THE VOCABULARY.  KTAB[N] IS THE WORD NUMBER, ATAB[N] IS
// THE CORRESPONDING WORD.  THE -1 AT THE END OF SECTION 4 IS LEFT IN KTAB
// AS AN END-MARKER. 
function parseVocab(ndx) {
	var TABNDX = 1;
	while (++ndx, KTAB[TABNDX] = parseInt(LINES[ndx]), KTAB[TABNDX] != -1) {
		ATAB[TABNDX++] = LINES[ndx].substr(8, 5).trim();
	};
};

// READ IN THE INITIAL LOCATIONS FOR EACH OBJECT.  ALSO THE IMMOVABILITY INFO.
// PLAC CONTAINS INITIAL LOCATIONS OF OBJECTS.  FIXD IS -1 FOR IMMOVABLE
// OBJECTS (INCLUDING THE SNAKE) , OR  =  SECOND LOC FOR TWO-PLACED OBJECTS.
function initObj(ndx) {
	var line = new Array(),
		obj;
	while (++ndx, line = LINES[ndx].split(/[ ]+/).map(Number), obj = line.shift(), obj != -1) {
		PLAC[obj] = line.shift();
		FIXD[obj] = line.shift();
	}
}

// READ DEFAULT MESSAGE NUMBERS FOR ACTION VERBS, STORE IN ACTSPK.
function defMssg(ndx) {
	var verb;
	while (++ndx, verb = parseInt(LINES[ndx]), verb != -1) {
		ACTSPK[verb] = parseInt(LINES[ndx].substr(8));
	}
}

// READ INFO ABOUT AVAILABLE LIQUIDS AND OTHER CONDITIONS, STORE IN COND.
function initCond(ndx) {
	var tk = new Array(),
		k;
	while (++ndx, tk = LINES[ndx].split(/[ ]+/).map(Number), k = tk.shift(), k != -1) {
        for (var t in tk) {
            if (tk[t] != 0) COND[tk[t]] += (1<<k);
		}
	}
}

// READ DATA FOR HINTS.
function initHint(ndx) {
	var tk = new Array(),
		k;
	while (++ndx, tk = LINES[ndx].split(/[ ]+/).map(Number), k = tk.shift(), k != -1) {
        for (var t = 0; t < 4; t++) {
            HINTS[k][t] = tk[t];
            HNTMAX = Math.max(HNTMAX, k);
		}
	}
}

//C  IF SETUP = 2 WE DON'T NEED TO DO THIS.  IT'S ONLY NECESSARY IF WE HAVEN'T DONE
//C  IT AT ALL OR IF THE PROGRAM HAS BEEN RUN SINCE THEN.
//
//1100	
//	if (SETUP == 2) GOTO 1;
//	if (SETUP == -1) GOTO 8305


// HAVING READ IN THE DATABASE, CERTAIN THINGS ARE NOW CONSTRUCTED.  PROPS ARE
// SET TO ZERO.  WE FINISH SETTING UP COND BY CHECKING FOR FORCED-MOTION TRAVEL
// ENTRIES.  THE PLAC AND FIXD ARRAYS ARE USED TO SET UP ATLOC[N] AS THE FIRST
// OBJECT AT LOCATION N, AND LINK[OBJ] AS THE NEXT OBJECT AT THE SAME LOCATION
// AS OBJ.  (OBJ>100 INDICATES THAT FIXED[OBJ-100] = LOC; LINK[OBJ] IS STILL THE
// CORRECT LINK TO USE.)   ABB IS ZEROED; IT CONTROLS WHETHER THE ABBREVIATED
// DESCRIPTION IS PRINTED.  COUNTS MOD 5 UNLESS "LOOK" IS USED.
function setupFixedMotion() {
	for (var i = 1; i <= 100; i++) { 
		PLACE[i] = 0;
		PROP[i] = 0;
		LINK[i] = 0;
		LINK[i+100] = 0;
	}

	for (var i = 1; i <= LOCSIZ; i++) { 
        if (LTEXT[i] != 0 && KEY[i] != 0) {
        	var k = KEY[i];
            if (Math.abs(TRAVEL[k]) % 1000  == 1) COND[i] = 2;
		};
		ATLOC[i] = 0;
		ABB[i] = 0;
	}
}

// SET UP THE ATLOC AND LINK ARRAYS AS DESCRIBED ABOVE.  WE'LL USE THE DROP
// SUBROUTINE, WHICH PREFACES NEW OBJECTS ON THE LISTS.  SINCE WE WANT THINGS
// IN THE OTHER ORDER, WE'LL RUN THE LOOP BACKWARDS.  IF THE OBJECT IS IN TWO
// LOCS, WE DROP IT TWICE.  THIS ALSO SETS UP "PLACE" AND "FIXED" AS COPIES OF
// "PLAC" AND "FIXD".  ALSO, SINCE TWO-PLACED OBJECTS ARE TYPICALLY BEST
// DESCRIBED LAST, WE'LL DROP THEM FIRST.
function setupAtLoc() {
	for (var i = 1; i <= 100; i++) { 
		var k = 101-i;
		if (FIXD[k] > 0) {
			DROP(k+100, FIXD[k]);
			DROP(k, PLAC[k]);
		}
	}

	for (var i = 1; i <= 100; i++) {
		var k = 101-i;
		FIXED[k] = FIXD[k];
		if (PLAC[k] !=  0 && FIXD[k] <=  0) {
			DROP(k, PLAC[k]);
		}
	}
}

// TREASURES, AS NOTED EARLIER, ARE OBJECTS 50 THROUGH MAXTRS (CURRENTLY 79) .
// THEIR PROPS ARE INITIALLY -1, AND ARE SET TO 0 THE FIRST TIME THEY ARE
// DESCRIBED.  TALLY KEEPS TRACK OF HOW MANY ARE NOT YET FOUND, SO WE KNOW
// WHEN TO CLOSE THE CAVE.  TALLY2 COUNTS HOW MANY CAN NEVER BE FOUND (E.G. IF
// LOST BIRD OR BRIDGE) .
function setupTreasures() {
	MAXTRS = 79;
	TALLY = 0;
	TALLY2 = 0;
	for (var i = 50; i <= MAXTRS; i++) {
		if (PTEXT[i] !=  0) PROP[i] = -1;
		TALLY = TALLY-PROP[i];
	}
}

// CLEAR THE HINT STUFF.  HINTLC[I] IS HOW LONG HE'S BEEN AT LOC WITH COND BIT
// I.  HINTED[I] IS TRUE IFF HINT I HAS BEEN USED.
function clearHintStuff() {
	for (var i = 1; i <= HNTMAX; i++) {
		HINTED[i] = false;
		HINTLC[i] = 0;
	}
}

//C  DEFINE SOME HANDY MNEMONICS.  THESE CORRESPOND TO OBJECT NUMBERS.
function defineMnemonics() {
	KEYS   = VOCAB('KEYS',1);
	LAMP   = VOCAB('LAMP',1);
	GRATE  = VOCAB('GRATE',1);
	CAGE   = VOCAB('CAGE',1);
	ROD    = VOCAB('ROD',1);
	ROD2   = ROD+1;
	STEPS  = VOCAB('STEPS',1);
	BIRD   = VOCAB('BIRD',1);
	DOOR   = VOCAB('DOOR',1);
	PILLOW = VOCAB('PILLO',1);
	SNAKE  = VOCAB('SNAKE',1);
	FISSUR = VOCAB('FISSU',1);
	TABLET = VOCAB('TABLE',1);
	CLAM   = VOCAB('CLAM',1);
	OYSTER = VOCAB('OYSTE',1);
	MAGZIN = VOCAB('MAGAZ',1);
	DWARF  = VOCAB('DWARF',1);
	KNIFE  = VOCAB('KNIFE',1);
	FOOD   = VOCAB('FOOD',1);
	BOTTLE = VOCAB('BOTTL',1);
	WATER  = VOCAB('WATER',1);
	OIL    = VOCAB('OIL',1);
	PLANT  = VOCAB('PLANT',1);
	PLANT2 = PLANT+1;
	AXE    = VOCAB('AXE',1);
	MIRROR = VOCAB('MIRRO',1);
	DRAGON = VOCAB('DRAGO',1);
	CHASM  = VOCAB('CHASM',1);
	TROLL  = VOCAB('TROLL',1);
	TROLL2 = TROLL+1;
	BEAR   = VOCAB('BEAR',1);
	MESSAG = VOCAB('MESSA',1);
	VEND   = VOCAB('VENDI',1);
	BATTER = VOCAB('BATTE',1);
// OBJECTS FROM 50 THROUGH WHATEVER ARE TREASURES.  HERE ARE A FEW.
	NUGGET = VOCAB('GOLD',1);
	COINS  = VOCAB('COINS',1);
	CHEST  = VOCAB('CHEST',1);
	EGGS   = VOCAB('EGGS',1);
	TRIDNT = VOCAB('TRIDE',1);
	VASE   = VOCAB('VASE',1);
	EMRALD = VOCAB('EMERA',1);
	PYRAM  = VOCAB('PYRAM',1);
	PEARL  = VOCAB('PEARL',1);
	RUG    = VOCAB('RUG',1);
	CHAIN  = VOCAB('CHAIN',1);
// THESE ARE MOTION-VERB NUMBERS.
	BACK   = VOCAB('BACK',0);
	LOOK   = VOCAB('LOOK',0);
	CAVE   = VOCAB('CAVE',0);
	NULL   = VOCAB('NULL',0);
	ENTRNC = VOCAB('ENTRA',0);
	DPRSSN = VOCAB('DEPRE',0);
// AND SOME ACTION VERBS.
	SAY    = VOCAB('SAY',2);
	LOCK   = VOCAB('LOCK',2);
	THROW  = VOCAB('THROW',2);
	FIND   = VOCAB('FIND',2);
	INVENT = VOCAB('INVEN',2);
}

//C  INITIALISE THE DWARVES.  DLOC IS LOC OF DWARVES, HARD-WIRED IN.  ODLOC IS
//C  PRIOR LOC OF EACH DWARF, INITIALLY GARBAGE.  DALTLC IS ALTERNATE INITIAL LOC
//C  FOR DWARF, IN CASE ONE OF THEM STARTS OUT ON TOP OF THE ADVENTURER.  (NO 2
//C  OF THE 5 INITIAL LOCS ARE ADJACENT.)   DSEEN IS TRUE IF DWARF HAS SEEN HIM.
//C  DFLAG CONTROLS THE LEVEL OF ACTIVATION OF ALL THIS:
//C	0	NO DWARF STUFF YET (WAIT UNTIL REACHES HALL OF MISTS) 
//C	1	REACHED HALL OF MISTS, BUT HASN'T MET FIRST DWARF
//C	2	MET FIRST DWARF, OTHERS START MOVING, NO KNIVES THROWN YET
//C	3	A KNIFE HAS BEEN THROWN (FIRST SET ALWAYS MISSES) 
//C	3+	DWARVES ARE MAD (INCREASES THEIR ACCURACY) 
//C  SIXTH DWARF IS SPECIAL (THE PIRATE) .  HE ALWAYS STARTS AT HIS CHEST'S
//C  EVENTUAL LOCATION INSIDE THE MAZE.  THIS LOC IS SAVED IN CHLOC FOR REF.
//C  THE DEAD END IN THE OTHER MAZE HAS ITS LOC STORED IN CHLOC2.
function initDwarves() {
	CHLOC = 114;
	CHLOC2 = 140;
	for (var i = 1; i <= 6; i++) DSEEN[i] = false;
	DFLAG = 0;
	DLOC[1] = 19;
	DLOC[2] = 27;
	DLOC[3] = 33;
	DLOC[4] = 44;
	DLOC[5] = 64;
	DLOC[6] = CHLOC;
	DALTLC = 18;
}

function initGlobals() {
	TURNS = 0;
	LMWARN = false;
	IWEST = 0;
	KNFLOC = 0;
	DETAIL = 0;
	ABBNUM = 5;
	for (var i = 1; i <= 4; i++) {
		if (RTEXT[2*i+81] != 0) MAXDIE = i+1; 
	}
	NUMDIE = 0;
	HOLDNG = 0;
	DKILL = 0;
	FOOBAR = 0;
	BONUS = 0;
	CLOCK1 = 30;
	CLOCK2 = 50;
	SAVED = 0;
	CLOSNG =  false;
	PANIC =  false;
	CLOSED =  false;
	GAVEUP =  false;
	SCORNG =  false;
}

//

//C  START-UP, DWARF STUFF
//
setup(); // read the database & set up variables

start();

function start() {
	
	HINTED[3] = YES(65,1,0); // Check if he wants a hint
	NEWLOC = 1; // Set the new location
	LIMIT = 330; // The limit is 330 moves unless he has taken a hint
	if (HINTED[3]) LIMIT = 1000;
	// start calling functions
	
}
//No demos shall be given
//1	DEMO = START(0)
//	CALL MOTD( false) 

//??
//	I = RAN(1) 



//
//C  CAN'T LEAVE CAVE ONCE IT'S CLOSING (EXCEPT BY MAIN OFFICE) .
//we come back here...
//2	if (NEWLOC >=  9 || NEWLOC == 0 ||  !CLOSNG) GOTO 71
//	CALL RSPEAK(130) 
//	NEWLOC = LOC
//	if ( !PANIC) CLOCK2 = 15
//	PANIC =  true
//
//C  SEE IF A DWARF HAS SEEN HIM AND HAS COME FROM WHERE HE WANTS TO GO.  IF SO,
//C  THE DWARF'S BLOCKING HIS WAY.  IF COMING FROM PLACE FORBIDDEN TO PIRATE
//C  (DWARVES ROOTED IN PLACE)  LET HIM GET OUT (AND ATTACKED) .
//
//71	if (NEWLOC == LOC || FORCED(LOC)  || BITSET(LOC,3) ) GOTO 74
		for (var I = 1; I <= 5; I++) {
			if (ODLOC[I] != NEWLOC || !DSEEN[I]) {} // GOTO 73;
			NEWLOC = LOC;
			RSPEAK(2);
			// GOTO 74;
//73		
		};
//74
		LOC = NEWLOC;
//
//C  DWARF STUFF.  SEE EARLIER COMMENTS FOR DESCRIPTION OF VARIABLES.  REMEMBER
//C  SIXTH DWARF IS PIRATE AND IS THUS VERY DIFFERENT EXCEPT FOR MOTION RULES.
//
//C  FIRST OFF, DON'T LET THE DWARVES FOLLOW HIM INTO A PIT OR A WALL.  ACTIVATE
//C  THE WHOLE MESS THE FIRST TIME HE GETS AS FAR AS THE HALL OF MISTS (LOC 15) .
//C  IF NEWLOC IS FORBIDDEN TO PIRATE (IN PARTICULAR, IF IT'S BEYOND THE TROLL
//C  BRIDGE) , BYPASS DWARF STUFF.  THAT WAY PIRATE CAN'T STEAL RETURN TOLL, AND
//C  DWARVES CAN'T MEET THE BEAR.  ALSO MEANS DWARVES WON'T FOLLOW HIM INTO DEAD
//C  END IN MAZE, BUT C'EST LA VIE.  THEY'LL WAIT FOR HIM OUTSIDE THE DEAD END.
//
//	if (LOC == 0 || FORCED(LOC)  || BITSET(NEWLOC,3) ) GOTO 2000
//	if (DFLAG ! =  0) GOTO 6000
//	if (LOC >=  15) DFLAG = 1
//	GOTO 2000
//
//C  WHEN WE ENCOUNTER THE FIRST DWARF, WE KILL 0, 1, OR 2 OF THE 5 DWARVES.  IF
//C  ANY OF THE SURVIVORS IS AT LOC, REPLACE HIM WITH THE ALTERNATE.
//
//6000	
		if (DFLAG !=  1) {} //GOTO 6010;
		if (LOC < 15 || PCT(95) ) {} //GOTO 2000;
		DFLAG = 2;
		for (var I = 1; I <= 2; I++) {
		J = 1+RAN(5) ;
		// IF SAVED NOT  =  -1, HE BYPASSED THE "START" CALL.
//6001	
		if (PCT(50)  && SAVED == -1) DLOC[J] = 0; }
		for (var I = 1; I <= 5; I++) { 
			if (DLOC[I] == LOC) DLOC[I] = DALTLC;
//6002
			ODLOC[I] = DLOC[I]; }
		RSPEAK(3) ;
		DROP(AXE,LOC) ;
		//GOTO 2000;
//
//C  THINGS ARE IN FULL SWING.  MOVE EACH DWARF AT RANDOM, EXCEPT IF HE'S SEEN US
//C  HE STICKS WITH US.  DWARVES NEVER GO TO LOCS <15.  IF WANDERING AT RANDOM,
//C  THEY DON'T BACK UP UNLESS THERE'S NO ALTERNATIVE.  IF THEY DON'T HAVE TO
//C  MOVE, THEY ATTACK.  AND, OF COURSE, DEAD DWARVES DON'T DO MUCH OF ANYTHING.
//
//6010	DTOTAL = 0
//	ATTACK = 0
//	STICK = 0
		for (var I = 1; I <= 6; I++) { 
//	if (DLOC[I] == 0) GOTO 6030
//	J = 1
//	KK = DLOC[I]
//	KK = KEY[KK]
//	if (KK == 0) GOTO 6016
//6012	NEWLOC = Math.abs(TRAVEL[KK])/1000 % 1000)
//	if (NEWLOC > 300 || NEWLOC < 15 || NEWLOC == ODLOC[I]
//	1	 || (J > 1 && NEWLOC == TK[J-1])  || J >=  20
//	2	 || NEWLOC == DLOC[I] || FORCED(NEWLOC) 
//	3	 || (I == 6 && BITSET(NEWLOC,3) ) 
//	4	 || Math.abs(TRAVEL[KK]) /1000000 == 100) GOTO 6014
//	TK[J] = NEWLOC
//	J = J+1
//6014	KK = KK+1
//	if (TRAVEL[KK-1] >=  0) GOTO 6012
//6016	TK[J] = ODLOC[I]
//	if (J >=  2) J = J-1
//	J = 1+RAN(J) 
//	ODLOC[I] = DLOC[I]
//	DLOC[I] = TK[J]
//	DSEEN[I] = (DSEEN[I] && LOC >=  15) 
//	1	 || (DLOC[I] == LOC || ODLOC[I] == LOC) 
//	if ( !DSEEN[I]) GOTO 6030
//	DLOC[I] = LOC
//	if (I ! =  6) GOTO 6027
//
//C  THE PIRATE'S SPOTTED HIM.  HE LEAVES HIM ALONE ONCE WE'VE FOUND CHEST.
//C  K COUNTS IF A TREASURE IS HERE.  IF NOT, AND TALLY = TALLY2 PLUS ONE FOR
//C  AN UNSEEN CHEST, LET THE PIRATE BE SPOTTED.
//
//	if (LOC == CHLOC || PROP[CHEST] >=  0) GOTO 6030
//	K = 0
		for (var J = 50; J <= MAXTRS; J++) {
//C  PIRATE WON'T TAKE PYRAMID FROM PLOVER ROOM OR DARK ROOM (TOO EASY!) .
//	if (J == PYRAM && (LOC == PLAC[PYRAM]
//	1	 || LOC == PLAC[EMRALD]) ) GOTO 6020
//	IDONDX = J
//	if (TOTING(IDONDX) ) GOTO 6022
//6020
	if (HERE(IDONDX) ) K = 1; }
//	if (TALLY == TALLY2+1 && K == 0 && PLACE[CHEST] == 0
//	1	 && HERE(LAMP)  && PROP[LAMP] == 1) GOTO 6025
//	if (ODLOC[6] ! =  DLOC[6] && PCT(20) ) CALL RSPEAK(127) 
//	GOTO 6030
//
//6022	CALL RSPEAK(128) 
//C  DON'T STEAL CHEST BACK FROM TROLL!
//	if (PLACE[MESSAG] == 0) CALL MOVE(CHEST,CHLOC) 
//	CALL MOVE(MESSAG,CHLOC2) 
		for (var J = 50; J <= MAXTRS; J++) {
//	if (J == PYRAM && (LOC == PLAC[PYRAM]
//	1	 || LOC == PLAC[EMRALD]) ) GOTO 6023
//	IDONDX = J
//	if (AT(IDONDX)  && FIXED[IDONDX] == 0) 
//	1 CALL CARRY(IDONDX,LOC) 
//	if (TOTING(IDONDX) ) CALL DROP(IDONDX,CHLOC) 
//6023	
		}
//6024	DLOC[6] = CHLOC
//	ODLOC[6] = CHLOC
//	DSEEN[6] =  false
//	GOTO 6030
//
//6025	CALL RSPEAK(186) 
//	CALL MOVE(CHEST,CHLOC) 
//	CALL MOVE(MESSAG,CHLOC2) 
//	GOTO 6024
//
//C  THIS THREATENING LITTLE DWARF IS IN THE ROOM WITH HIM!
//
//6027	DTOTAL = DTOTAL+1
//	if (ODLOC[I] ! =  DLOC[I]) GOTO 6030
//	ATTACK = ATTACK+1
//	if (KNFLOC >=  0) KNFLOC = LOC
//	if (RAN(1000)  < 95*(DFLAG-2) ) STICK = STICK+1
//6030	
		}
//
//C  NOW WE KNOW WHAT'S HAPPENING.  LET'S TELL THE POOR SUCKER ABOUT IT.
//
//	if (DTOTAL == 0) GOTO 2000
//	if (DTOTAL == 1) GOTO 75
//	TYPE 67,DTOTAL
//67	FORMAT(/' There are ',I1,' threatening little dwarves in the'
//	1	,' room with you.') 
//	GOTO 77
//75	CALL RSPEAK(4) 
//77	if (ATTACK == 0) GOTO 2000
//	if (DFLAG == 2) DFLAG = 3
//C  IF SAVED NOT  =  -1, HE BYPASSED THE "START" CALL.  DWARVES GET *VERY* MAD!
//	if (SAVED ! =  -1) DFLAG = 20
//	if (ATTACK == 1) GOTO 79
//	TYPE 78,ATTACK
//78	FORMAT(/' ',I1,' of them throw knives at you!') 
//	K = 6
//82	if (STICK > 1) GOTO 83
//	CALL RSPEAK(K+STICK) 
//	if (STICK == 0) GOTO 2000
//	GOTO 84
//83	TYPE 68,STICK
//68	FORMAT(/' ',I1,' of them get you!') 
//84	OLDLC2 = LOC
//	GOTO 99
//
//79	CALL RSPEAK(5) 
//	K = 52
//	GOTO 82
//C  DESCRIBE THE CURRENT LOCATION AND (MAYBE)  GET NEXT COMMAND.
//
//C  PRINT TEXT FOR CURRENT LOC.
//
//2000	if (LOC == 0) GOTO 99
//	KK = STEXT[LOC]
//	if (ABB[LOC] % ABBNUM == 0 || KK == 0) KK = LTEXT[LOC]
//	if (FORCED(LOC)  ||  !DARK(0) ) GOTO 2001
//	if (WZDARK && PCT(35) ) GOTO 90
//	KK = RTEXT[16]
//2001	if (TOTING(BEAR) ) CALL RSPEAK(141) 
//	CALL SPEAK(KK) 
//	K = 1
//	if (FORCED(LOC) ) GOTO 8
//	if (LOC == 33 && PCT(25)  &&  !CLOSNG) CALL RSPEAK(8) 
//
//C  PRINT OUT DESCRIPTIONS OF OBJECTS AT THIS LOCATION.  IF NOT CLOSING AND
//C  PROPERTY VALUE IS NEGATIVE, TALLY OFF ANOTHER TREASURE.  RUG IS SPECIAL
//C  CASE; ONCE SEEN, ITS PROP IS 1 (DRAGON ON IT)  TILL DRAGON IS KILLED.
//C  SIMILARLY FOR CHAIN; PROP IS INITIALLY 1 (LOCKED TO BEAR) .  THESE HACKS
//C  ARE BECAUSE PROP = 0 IS NEEDED TO GET FULL SCORE.
//
//	if (DARK(0) ) GOTO 2012
//	ABB[LOC] = ABB[LOC]+1
//	I = ATLOC[LOC]
//2004	if (I == 0) GOTO 2012
//	OBJ = I
//	if (OBJ > 100) OBJ = OBJ-100
//	if (OBJ == STEPS && TOTING(NUGGET) ) GOTO 2008
//	if (PROP[OBJ] >=  0) GOTO 2006
//	if (CLOSED) GOTO 2008
//	PROP[OBJ] = 0
//	if (OBJ == RUG || OBJ == CHAIN) PROP[OBJ] = 1
//	TALLY = TALLY-1
//C  IF REMAINING TREASURES TOO ELUSIVE, ZAP HIS LAMP.
//	if (TALLY == TALLY2 && TALLY ! =  0) LIMIT = MIN0(35,LIMIT) 
//2006	KK = PROP[OBJ]
//	if (OBJ == STEPS && LOC == FIXED[STEPS]) KK = 1
//	CALL PSPEAK(OBJ,KK) 
//2008	I = LINK[I]
//	GOTO 2004
//
//2009	K = 54
//2010	SPK = K
//2011	CALL RSPEAK(SPK) 
//
//2012	VERB = 0
//	OBJ = 0
//
//C  CHECK IF THIS LOC IS ELIGIBLE FOR ANY HINTS.  IF BEEN HERE LONG ENOUGH,
//C  BRANCH TO HELP SECTION (ON LATER PAGE) .  HINTS ALL COME BACK HERE EVENTUALLY
//C  TO FINISH THE LOOP.  IGNORE "HINTS" < 4 (SPECIAL STUFF, SEE DATABASE NOTES) .
//
		for (var HINT = 4; HINT <= HNTMAX; HINT++) {
//	if (HINTED[HINT]) GOTO 2602
//	IDONDX = HINT
//	if ( !BITSET(LOC,IDONDX) ) HINTLC[HINT] = -1
//	HINTLC[HINT] = HINTLC[HINT]+1
//	if (HINTLC[HINT] >=  HINTS[HINT,1]) GOTO 40000
//2602
			}
//
//C  KICK THE RANDOM NUMBER GENERATOR JUST TO ADD VARIETY TO THE CHASE.  ALSO,
//C  IF CLOSING TIME, CHECK FOR ANY OBJECTS BEING TOTED WITH PROP < 0 AND SET
//C  THE PROP TO -1-PROP.  THIS WAY OBJECTS WON'T BE DESCRIBED UNTIL THEY'VE
//C  BEEN PICKED UP AND PUT DOWN SEPARATE FROM THEIR RESPECTIVE PILES.  DON'T
//C  TICK CLOCK1 UNLESS WELL INTO CAVE (AND NOT AT Y2) .
//
//	if ( !CLOSED) GOTO 2605
//	if (PROP[OYSTER] < 0 && TOTING(OYSTER) ) 
//	1	CALL PSPEAK(OYSTER,1) 
		for (var I = 1; I <= 100; I++) {
			IDONDX = I;
//2604
	if (TOTING(IDONDX)  && PROP[IDONDX] < 0) PROP[IDONDX] = -1-PROP[IDONDX]; }
//2605	WZDARK = DARK(0) 
//	if (KNFLOC > 0 && KNFLOC ! =  LOC) KNFLOC = 0
//	I = RAN(1) 
//	CALL GETIN(WD1,WD1X,WD2,WD2X) 
//
//C  EVERY INPUT, CHECK "FOOBAR" FLAG.  IF ZERO, NOTHING'S GOING ON.  IF POS,
//C  MAKE NEG.  IF NEG, HE SKIPPED A WORD, SO MAKE IT ZERO.
//
//2608	FOOBAR = MIN0(0,-FOOBAR) 
//	if (TURNS == 0 && WD1 == 'MAGIC' && WD2 == 'MODE') CALL MAINT
//	TURNS = TURNS+1
//	if (DEMO && TURNS >=  SHORT) GOTO 13000
//	if (VERB == SAY && WD2 ! =  0) VERB = 0
//	if (VERB == SAY) GOTO 4090
//	if (TALLY == 0 && LOC >=  15 && LOC ! =  33) CLOCK1 = CLOCK1-1
//	if (CLOCK1 == 0) GOTO 10000
//	if (CLOCK1 < 0) CLOCK2 = CLOCK2-1
//	if (CLOCK2 == 0) GOTO 11000
//	if (PROP[LAMP] == 1) LIMIT = LIMIT-1
//	if (LIMIT <=  30 && HERE(BATTER)  && PROP[BATTER] == 0
//	1	 && HERE(LAMP) ) GOTO 12000
//	if (LIMIT == 0) GOTO 12400
//	if (LIMIT < 0 && LOC <=  8) GOTO 12600
//	if (LIMIT <=  30) GOTO 12200
//19999	K = 43
//	if (LIQLOC(LOC)  == WATER) K = 70
//	if (WD1 == 'ENTER' && (WD2 == 'STREA' || WD2 == 'WATER') ) 
//	1	GOTO 2010
//	if (WD1 == 'ENTER' && WD2 ! =  0) GOTO 2800
//	if ((WD1 ! =  'WATER' && WD1 ! =  'OIL') 
//	1	 || (WD2 ! =  'PLANT' && WD2 ! =  'DOOR') ) GOTO 2610
//	if (AT(VOCAB(WD2,1) ) ) WD2 = 'POUR'
//2610	if (WD1 ! =  'WEST') GOTO 2630
//	IWEST = IWEST+1
//	if (IWEST == 10) CALL RSPEAK(17) 
//2630	I = VOCAB(WD1,-1) 
//	if (I == -1) GOTO 3000
//	K = I % 1000; 
//	KQ = I/1000+1
//	GOTO (8,5000,4000,2010) KQ
//	CALL BUG(22) 
//
//C  GET SECOND WORD FOR ANALYSIS.
//
//2800	WD1 = WD2
//	WD1X = WD2X
//	WD2 = 0
//	GOTO 2610
//
//C  GEE, I DON'T UNDERSTAND.
//
//3000	SPK = 60
//	if (PCT(20) ) SPK = 61
//	if (PCT(20) ) SPK = 13
//	CALL RSPEAK(SPK) 
//	GOTO 2600
//
//C  ANALYSE A VERB.  REMEMBER WHAT IT WAS, GO BACK FOR OBJECT IF SECOND WORD
//C  UNLESS VERB IS "SAY", WHICH SNARFS ARBITRARY SECOND WORD.
//
//4000	VERB = K
//	SPK = ACTSPK[VERB]
//	if (WD2 ! =  0 && VERB ! =  SAY) GOTO 2800
//	if (VERB == SAY) OBJ = WD2
//	if (OBJ ! =  0) GOTO 4090
//
//C  ANALYSE AN INTRANSITIVE VERB (IE, NO OBJECT GIVEN YET) .
//
//4080	GOTO(8010,8000,8000,8040,2009,8040,9070,9080,8000,8000,
//	1    2011,9120,9130,8140,9150,8000,8000,8180,8000,8200,
//	2    8000,9220,9230,8240,8250,8260,8270,8000,8000,8300,
//	3    8310) VERB
//C	     TAKE DROP  SAY OPEN NOTH LOCK   ON  OFF WAVE CALM
//C	     WALK KILL POUR  EAT DRNK  RUB TOSS QUIT FIND INVN
//C	     FEED FILL BLST SCOR  FOO  BRF READ BREK WAKE SUSP
//C	     HOUR
//	CALL BUG(23) 
//
//C  ANALYSE A TRANSITIVE VERB.
//
//4090	GOTO(9010,9020,9030,9040,2009,9040,9070,9080,9090,2011,
//	1    2011,9120,9130,9140,9150,9160,9170,2011,9190,9190,
//	2    9210,9220,9230,2011,2011,2011,9270,9280,9290,2011,
//	3    2011) VERB
//C	     TAKE DROP  SAY OPEN NOTH LOCK   ON  OFF WAVE CALM
//C	     WALK KILL POUR  EAT DRNK  RUB TOSS QUIT FIND INVN
//C	     FEED FILL BLST SCOR  FOO  BRF READ BREK WAKE SUSP
//C	     HOUR
//	CALL BUG(24) 
//
//C  ANALYSE AN OBJECT WORD.  SEE IF THE THING IS HERE, WHETHER WE'VE GOT A VERB
//C  YET, AND SO ON.  OBJECT MUST BE HERE UNLESS VERB IS "FIND" OR "INVENT(ORY) "
//C  (AND NO NEW VERB YET TO BE ANALYSED) .  WATER AND OIL ARE ALSO FUNNY, SINCE
//C  THEY ARE NEVER ACTUALLY DROPPED AT ANY LOCATION, BUT MIGHT BE HERE INSIDE
//C  THE BOTTLE OR AS A FEATURE OF THE LOCATION.
//
//5000	OBJ = K
//	if (FIXED[K] ! =  LOC &&  !HERE(K) ) GOTO 5100
//5010	if (WD2 ! =  0) GOTO 2800
//	if (VERB ! =  0) GOTO 4090
//	CALL A5TOA1(WD1,WD1X,'?',TK,K) 
//	TYPE 5015,(TK[I],I = 1,K) 
//5015	FORMAT(/' What do you want to do with the ',20A1) 
//	GOTO 2600
//
//5100	if (K ! =  GRATE) GOTO 5110
//	if (LOC == 1 || LOC == 4 || LOC == 7) K = DPRSSN
//	if (LOC > 9 && LOC < 15) K = ENTRNC
//	if (K ! =  GRATE) GOTO 8
//5110	if (K ! =  DWARF) GOTO 5120
	for (var I = 1; I <= 5; I++) {
		if (DLOC[I] == LOC && DFLAG >=  2) {}//GOTO 5010;
	}
//5120	if ((LIQ(0)  == K && HERE(BOTTLE) )  || K == LIQLOC(LOC) ) GOTO 5010
//	if (OBJ ! =  PLANT ||  !AT(PLANT2)  || PROP[PLANT2] == 0) GOTO 5130
//	OBJ = PLANT2
//	GOTO 5010
//5130	if (OBJ ! =  KNIFE || KNFLOC ! =  LOC) GOTO 5140
//	KNFLOC = -1
//	SPK = 116
//	GOTO 2011
//5140	if (OBJ ! =  ROD ||  !HERE(ROD2) ) GOTO 5190
//	OBJ = ROD2
//	GOTO 5010
//5190	if ((VERB == FIND || VERB == INVENT)  && WD2 == 0) GOTO 5010
//	CALL A5TOA1(WD1,WD1X,'here.',TK,K) 
//	TYPE 5199,(TK[I],I = 1,K) 
//5199	FORMAT(/' I see no ',20A1) 
//	GOTO 2012
//C  FIGURE OUT THE NEW LOCATION
//C
//C  GIVEN THE CURRENT LOCATION IN "LOC", AND A MOTION VERB NUMBER IN "K", PUT
//C  THE NEW LOCATION IN "NEWLOC".  THE CURRENT LOC IS SAVED IN "OLDLOC" IN CASE
//C  HE WANTS TO RETREAT.  THE CURRENT OLDLOC IS SAVED IN OLDLC2, IN CASE HE
//C  DIES.  (IF HE DOES, NEWLOC WILL BE LIMBO, AND OLDLOC WILL BE WHAT KILLED
//C  HIM, SO WE NEED OLDLC2, WHICH IS THE LAST PLACE HE WAS SAFE.) 
//
//8	KK = KEY[LOC]
//	NEWLOC = LOC
//	if (KK == 0) CALL BUG(26) 
//	if (K == NULL) GOTO 2
//	if (K == BACK) GOTO 20
//	if (K == LOOK) GOTO 30
//	if (K == CAVE) GOTO 40
//	OLDLC2 = OLDLOC
//	OLDLOC = LOC
//
//9	LL = Math.abs(TRAVEL[KK]) 
//	if (LL % 1000  == 1 || LL % 1000  == K) GOTO 10
//	if (TRAVEL[KK] < 0) GOTO 50
//	KK = KK+1
//	GOTO 9
//
//10	LL = LL/1000
//11	NEWLOC = LL/1000
//	K = NEWLOC % 100; 
//	if (NEWLOC <=  300) GOTO 13
//	if (PROP[K] ! =  NEWLOC/100-3) GOTO 16
//12	if (TRAVEL[KK] < 0) CALL BUG(25) 
//	KK = KK+1
//	NEWLOC = Math.abs(TRAVEL[KK]) /1000
//	if (NEWLOC == LL) GOTO 12
//	LL = NEWLOC
//	GOTO 11
//
//13	if (NEWLOC <=  100) GOTO 14
//	if (TOTING(K)  || (NEWLOC > 200 && AT(K) ) ) GOTO 16
//	GOTO 12
//
//14	if (NEWLOC ! =  0 &&  !PCT(NEWLOC) ) GOTO 12
//16	NEWLOC = LL % 1000;
//	if (NEWLOC <=  300) GOTO 2
//	if (NEWLOC <=  500) GOTO 30000
//	CALL RSPEAK(NEWLOC-500) 
//	NEWLOC = LOC
//	GOTO 2
//
//C  SPECIAL MOTIONS COME HERE.  LABELLING CONVENTION: STATEMENT NUMBERS NNNXX
//C  (XX = 00-99)  ARE USED FOR SPECIAL CASE NUMBER NNN (NNN = 301-500) .
//
//30000	NEWLOC = NEWLOC-300
//	GOTO (30100,30200,30300) NEWLOC
//	CALL BUG(20) 
//
//C  TRAVEL 301.  PLOVER-ALCOVE PASSAGE.  CAN CARRY ONLY EMERALD.  NOTE: TRAVEL
//C  TABLE MUST INCLUDE "USELESS" ENTRIES GOING THROUGH PASSAGE, WHICH CAN NEVER
//C  BE USED FOR ACTUAL MOTION, BUT CAN BE SPOTTED BY "GO BACK".
//
//30100	NEWLOC = 99+100-LOC
//	if (HOLDNG == 0 || (HOLDNG == 1 && TOTING(EMRALD) ) ) GOTO 2
//	NEWLOC = LOC
//	CALL RSPEAK(117) 
//	GOTO 2
//
//C  TRAVEL 302.  PLOVER TRANSPORT.  DROP THE EMERALD (ONLY USE SPECIAL TRAVEL IF
//C  TOTING IT) , SO HE'S FORCED TO USE THE PLOVER-PASSAGE TO GET IT OUT.  HAVING
//C  DROPPED IT, GO BACK AND PRETEND HE WASN'T CARRYING IT AFTER ALL.
//
//30200	CALL DROP(EMRALD,LOC) 
//	GOTO 12
//
//C  TRAVEL 303.  TROLL BRIDGE.  MUST BE DONE ONLY AS SPECIAL MOTION SO THAT
//C  DWARVES WON'T WANDER ACROSS AND ENCOUNTER THE BEAR.  (THEY WON'T FOLLOW THE
//C  PLAYER THERE BECAUSE THAT REGION IS FORBIDDEN TO THE PIRATE.)   IF
//C  PROP[TROLL] = 1, HE'S CROSSED SINCE PAYING, SO STEP OUT AND BLOCK HIM.
//C  (STANDARD TRAVEL ENTRIES CHECK FOR PROP[TROLL] = 0.)   SPECIAL STUFF FOR BEAR.
//
//30300	if (PROP[TROLL] ! =  1) GOTO 30310
//	CALL PSPEAK(TROLL,1) 
//	PROP[TROLL] = 0
//	CALL MOVE(TROLL2,0) 
//	CALL MOVE(TROLL2+100,0) 
//	CALL MOVE(TROLL,PLAC[TROLL]) 
//	CALL MOVE(TROLL+100,FIXD[TROLL]) 
//	CALL JUGGLE(CHASM) 
//	NEWLOC = LOC
//	GOTO 2
//
//30310	NEWLOC = PLAC[TROLL]+FIXD[TROLL]-LOC
//	if (PROP[TROLL] == 0) PROP[TROLL] = 1
//	if ( !TOTING(BEAR) ) GOTO 2
//	CALL RSPEAK(162) 
//	PROP[CHASM] = 1
//	PROP[TROLL] = 2
//	CALL DROP(BEAR,NEWLOC) 
//	FIXED[BEAR] = -1
//	PROP[BEAR] = 3
//	if (PROP[SPICES] < 0) TALLY2 = TALLY2+1
//	OLDLC2 = NEWLOC
//	GOTO 99
//
//C  END OF SPECIALS.
//
//C  HANDLE "GO BACK".  LOOK FOR VERB WHICH GOES FROM LOC TO OLDLOC, OR TO OLDLC2
//C  IF OLDLOC HAS FORCED-MOTION.  K2 SAVES ENTRY -> FORCED LOC -> PREVIOUS LOC.
//
//20	K = OLDLOC
//	if (FORCED(K) ) K = OLDLC2
//	OLDLC2 = OLDLOC
//	OLDLOC = LOC
//	K2 = 0
//	if (K ! =  LOC) GOTO 21
//	CALL RSPEAK(91) 
//	GOTO 2
//
//21	LL = (Math.abs(TRAVEL[KK]) /1000) % 1000;
//	if (LL == K) GOTO 25
//	if (LL > 300) GOTO 22
//	J = KEY[LL]
//	if (FORCED(LL)  && (Math.abs(TRAVEL[J]) /1000) % 1000  == K) K2 = KK
//22	if (TRAVEL[KK] < 0) GOTO 23
//	KK = KK+1
//	GOTO 21
//
//23	KK = K2
//	if (KK ! =  0) GOTO 25
//	CALL RSPEAK(140) 
//	GOTO 2
//
//25	K = Math.abs(TRAVEL[KK]) % 1000; 
//	KK = KEY[LOC]
//	GOTO 9
//
//C  LOOK.  CAN'T GIVE MORE DETAIL.  PRETEND IT WASN'T DARK (THOUGH IT MAY "NOW"
//C  BE DARK)  SO HE WON'T FALL INTO A PIT WHILE STARING INTO THE GLOOM.
//
//30	if (DETAIL < 3) CALL RSPEAK(15) 
//	DETAIL = DETAIL+1
//	WZDARK =  false
//	ABB[LOC] = 0
//	GOTO 2
//
//C  CAVE.  DIFFERENT MESSAGES DEPENDING ON WHETHER ABOVE GROUND.
//
//40	if (LOC < 8) CALL RSPEAK(57) 
//	if (LOC >=  8) CALL RSPEAK(58) 
//	GOTO 2
//
//C  NON-APPLICABLE MOTION.  VARIOUS MESSAGES DEPENDING ON WORD GIVEN.
//
//50	SPK = 12
//	if (K >=  43 && K <=  50) SPK = 9
//	if (K == 29 || K == 30) SPK = 9
//	if (K == 7 || K == 36 || K == 37) SPK = 10
//	if (K == 11 || K == 19) SPK = 11
//	if (VERB == FIND || VERB == INVENT) SPK = 59
//	if (K == 62 || K == 65) SPK = 42
//	if (K == 17) SPK = 80
//	CALL RSPEAK(SPK) 
//	GOTO 2
//C  "YOU'RE DEAD, JIM."
//C
//C  IF THE CURRENT LOC IS ZERO, IT MEANS THE CLOWN GOT HIMSELF KILLED.  WE'LL
//C  ALLOW THIS MAXDIE TIMES.  MAXDIE IS AUTOMATICALLY SET BASED ON THE NUMBER OF
//C  SNIDE MESSAGES AVAILABLE.  EACH DEATH RESULTS IN A MESSAGE (81, 83, ETC.) 
//C  WHICH OFFERS REINCARNATION; IF ACCEPTED, THIS RESULTS IN MESSAGE 82, 84,
//C  ETC.  THE LAST TIME, IF HE WANTS ANOTHER CHANCE, HE GETS A SNIDE REMARK AS
//C  WE EXIT.  WHEN REINCARNATED, ALL OBJECTS BEING CARRIED GET DROPPED AT OLDLC2
//C  (PRESUMABLY THE LAST PLACE PRIOR TO BEING KILLED)  WITHOUT CHANGE OF PROPS.
//C  THE LOOP RUNS BACKWARDS TO ASSURE THAT THE BIRD IS DROPPED BEFORE THE CAGE.
//C  (THIS KLUGE COULD BE CHANGED ONCE WE'RE SURE ALL REFERENCES TO BIRD AND CAGE
//C  ARE DONE BY KEYWORDS.)   THE LAMP IS A SPECIAL CASE (IT WOULDN'T DO TO LEAVE
//C  IT IN THE CAVE) .  IT IS TURNED OFF AND LEFT OUTSIDE THE BUILDING (ONLY IF HE
//C  WAS CARRYING IT, OF COURSE) .  HE HIMSELF IS LEFT INSIDE THE BUILDING (AND
//C  HEAVEN HELP HIM IF HE TRIES TO XYZZY BACK INTO THE CAVE WITHOUT THE LAMP!) .
//C  OLDLOC IS ZAPPED SO HE CAN'T JUST "RETREAT".
//
//C  THE EASIEST WAY TO GET KILLED IS TO FALL INTO A PIT IN PITCH DARKNESS.
//
//90	CALL RSPEAK(23) 
//	OLDLC2 = LOC
//
//C  OKAY, HE'S DEAD.  LET'S GET ON WITH IT.
//
//99	if (CLOSNG) GOTO 95
//	YEA = YES(81+NUMDIE*2,82+NUMDIE*2,54) 
//	NUMDIE = NUMDIE+1
//	if (NUMDIE == MAXDIE ||  !YEA) GOTO 20000
//	PLACE[WATER] = 0
//	PLACE[OIL] = 0
//	if (TOTING(LAMP) ) PROP[LAMP] = 0
		for (var J = 1; J <= 100; J++) {
//	I = 101-J
//	if ( !TOTING(I) ) GOTO 98
//	K = OLDLC2
//	if (I == LAMP) K = 1
//	CALL DROP(I,K) 
//98		
		}
//	LOC = 3
//	OLDLOC = LOC
//	GOTO 2000
//
//C  HE DIED DURING CLOSING TIME.  NO RESURRECTION.  TALLY UP A DEATH AND EXIT.
//
//95	CALL RSPEAK(131) 
//	NUMDIE = NUMDIE+1
//	GOTO 20000
//C  ROUTINES FOR PERFORMING THE VARIOUS ACTION VERBS
//
//C  STATEMENT NUMBERS IN THIS SECTION ARE 8000 FOR INTRANSITIVE VERBS, 9000 FOR
//C  TRANSITIVE, PLUS TEN TIMES THE VERB NUMBER.  MANY INTRANSITIVE VERBS USE THE
//C  TRANSITIVE CODE, AND SOME VERBS USE CODE FOR OTHER VERBS, AS NOTED BELOW.
//
//C  RANDOM INTRANSITIVE VERBS COME HERE.  CLEAR OBJ JUST IN CASE (SEE "ATTACK") .
//


// 8000
// RANDOM INTRANSITIVE VERBS COME HERE.  CLEAR OBJ JUST IN CASE (SEE "ATTACK") .
function sayWhat(verb) {
	out(verb + "What?");
	OBJ = 0;
	return false;
	// return to 'check hints' (2600)
}

function verbTakeObj(){
if (toting(obj)){ 
	rSpeak(24, BLACK);  /* You are already carrying it!*/ 
	return false;
}

if (obj == PLANT && prop[PLANT] <= 0){
	rSpeak(115, BLACK); /* The plant has exceptionally deep
                    	   roots and cannot be pulled free.*/
	return false;
}

if (obj == BEAR  && prop[BEAR] == 1){ 
	rSpeak(169, BLACK); /* The bear is still chained to the wall.*/
return false;
}

if (obj == CHAIN && prop[CHAIN] != 0){ 
	rSpeak(170, BLACK);  /* The chain is still locked.*/
	return false;
}

if (fixed[obj] != 0){ 
	rSpeak(25, BLACK);   /* You can't be serious! */ 
	return false;
}

if (obj == WATER || obj == OIL){		
	if (here(BOTTLE) && liq() == obj)
		obj = BOTTLE;
	else{
		if (toting(BOTTLE))
			if (prop[BOTTLE] == 1){ /* empty */
				obj = BOTTLE;
				return verbFill();
			}
			else
				rSpeak(105, BLACK); /* Your bottle is already full.*/
		else  
			rSpeak(104, BLACK);     /* You have nothing in which to carry it. */
		return false;
	}
}

if (HOLDNG >= 7){
	/* You can't carry anything more. You'll have to drop something first. */
	rSpeak(92, BLACK);
return false;
}

if (obj == BIRD && prop[BIRD] == 0 && toting(ROD)){
	/* The bird was unafraid when you entered, but as you approach it becomes 
 	   disturbed and you cannot catch it. */
	rSpeak(26, BLACK); 
	return false;
}

if (obj == BIRD && prop[BIRD] == 0 && !toting(CAGE)){
	/* You can catch the bird, but you cannot carry it. */
	rSpeak(27, BLACK);
return false;
}

/* Otherwise it's good to go ... */
if (obj == WATER || obj == OIL)
	if (here(BOTTLE) && liq() == obj)
		obj = BOTTLE;

if (obj == BIRD && prop[BIRD] == 0)
	prop[BIRD] = 1; 
      
if ((obj == BIRD || obj == CAGE) && prop[BIRD] != 0) 
	carry(BIRD+CAGE-obj,loc);

carry(obj,loc);
 
var kObj = liq();
if (obj == BOTTLE && kObj != 0) 
	place[kObj] = -1;
    
rSpeak(54, BLACK); /* Ok */

return false;
}		
function take() {
	var spk = ACTSPK[VERB];
	//C  CARRY, NO OBJECT GIVEN YET.  OK IF ONLY ONE OBJECT PRESENT.
	if (OBJ ==  0) { /* Intransitive */
		if (ATLOC[LOC] == 0 || LINK[ATLOC[LOC]] !=  0) {
			return sayWhat(VERB);
		}
		for (var i = 1; i <= 5; i++) {
			if (DLOC[i] == LOC && DFLAG >= 2) { // check dwarves
				return sayWhat(VERB);
			}
		}
		OBJ = ATLOC[LOC]; // The one object present
	}
	// CARRY AN OBJECT.  SPECIAL CASES FOR BIRD AND CAGE (IF BIRD IN CAGE, CAN'T
	// TAKE ONE WITHOUT THE OTHER.  LIQUIDS ALSO SPECIAL, SINCE THEY DEPEND ON
	// STATUS OF BOTTLE.  ALSO VARIOUS SIDE EFFECTS, ETC.
	if (TOTING(OBJ)) { 
		RSPEAK(spk); /* You are already carrying it!*/ 
		return false;
	}
	spk = 25; /* You can't be serious! */ 
	if (OBJ == PLANT && PROP[PLANT] <= 0) spk = 115; 
	/* The plant has exceptionally deep roots and cannot be pulled free.*/
	if (OBJ == BEAR && PROP[BEAR] == 1) spk = 169;
	/* The bear is still chained to the wall.*/
	if (OBJ == CHAIN && PROP[BEAR] !=  0) spk = 170;
	/* The chain is still locked.*/
	if (FIXED[OBJ] != 0) { 
		RSPEAK(spk); 
		return false;
	}
}





//	if (OBJ ! =  WATER && OBJ ! =  OIL) GOTO 9017
//	if (HERE(BOTTLE)  && LIQ(0)  == OBJ) GOTO 9018
//	OBJ = BOTTLE
//	if (TOTING(BOTTLE)  && PROP[BOTTLE] == 1) GOTO 9220
//	if (PROP[BOTTLE] ! =  1) SPK = 105
//	if ( !TOTING(BOTTLE) ) SPK = 104
//	GOTO 2011
//9018	OBJ = BOTTLE
//9017	if (HOLDNG < 7) GOTO 9016
//	CALL RSPEAK(92) 
//	GOTO 2012
//9016	if (OBJ ! =  BIRD) GOTO 9014
//	if (PROP[BIRD] ! =  0) GOTO 9014
//	if ( !TOTING(ROD) ) GOTO 9013
//	CALL RSPEAK(26) 
//	GOTO 2012
//9013	if (TOTING(CAGE) ) GOTO 9015
//	CALL RSPEAK(27) 
//	GOTO 2012
//9015	PROP[BIRD] = 1
//9014	if ((OBJ == BIRD || OBJ == CAGE)  && PROP[BIRD] ! =  0) 
//	1	CALL CARRY(BIRD+CAGE-OBJ,LOC) 
//	CALL CARRY(OBJ,LOC) 
//	K = LIQ(0) 
//	if (OBJ == BOTTLE && K ! =  0) PLACE[K] = -1
//	GOTO 2009
//
//C  DISCARD OBJECT.  "THROW" ALSO COMES HERE FOR MOST OBJECTS.  SPECIAL CASES FOR
//C  BIRD (MIGHT ATTACK SNAKE OR DRAGON)  AND CAGE (MIGHT CONTAIN BIRD)  AND VASE.
//C  DROP COINS AT VENDING MACHINE FOR EXTRA BATTERIES.
//
//9020	if (TOTING(ROD2)  && OBJ == ROD &&  !TOTING(ROD) ) OBJ = ROD2
//	if ( !TOTING(OBJ) ) GOTO 2011
//	if (OBJ ! =  BIRD ||  !HERE(SNAKE) ) GOTO 9024
//	CALL RSPEAK(30) 
//	if (CLOSED) GOTO 19000
//	CALL DSTROY(SNAKE) 
//C  SET PROP FOR USE BY TRAVEL OPTIONS
//	PROP[SNAKE] = 1
//9021	K = LIQ(0) 
//	if (K == OBJ) OBJ = BOTTLE
//	if (OBJ == BOTTLE && K ! =  0) PLACE[K] = 0
//	if (OBJ == CAGE && PROP[BIRD] ! =  0) CALL DROP(BIRD,LOC) 
//	if (OBJ == BIRD) PROP[BIRD] = 0
//	CALL DROP(OBJ,LOC) 
//	GOTO 2012
//
//9024	if (OBJ ! =  COINS ||  !HERE(VEND) ) GOTO 9025
//	CALL DSTROY(COINS) 
//	CALL DROP(BATTER,LOC) 
//	CALL PSPEAK(BATTER,0) 
//	GOTO 2012
//
//9025	if (OBJ ! =  BIRD ||  !AT(DRAGON)  || PROP[DRAGON] ! =  0) GOTO 9026
//	CALL RSPEAK(154) 
//	CALL DSTROY(BIRD) 
//	PROP[BIRD] = 0
//	if (PLACE[SNAKE] == PLAC[SNAKE]) TALLY2 = TALLY2+1
//	GOTO 2012
//
//9026	if (OBJ ! =  BEAR ||  !AT(TROLL) ) GOTO 9027
//	CALL RSPEAK(163) 
//	CALL MOVE(TROLL,0) 
//	CALL MOVE(TROLL+100,0) 
//	CALL MOVE(TROLL2,PLAC[TROLL]) 
//	CALL MOVE(TROLL2+100,FIXD[TROLL]) 
//	CALL JUGGLE(CHASM) 
//	PROP[TROLL] = 2
//	GOTO 9021
//
//9027	if (OBJ == VASE && LOC ! =  PLAC[PILLOW]) GOTO 9028
//	CALL RSPEAK(54) 
//	GOTO 9021
//
//9028	PROP[VASE] = 2
//	if (AT(PILLOW) ) PROP[VASE] = 0
//	CALL PSPEAK(VASE,PROP[VASE]+1) 
//	if (PROP[VASE] ! =  0) FIXED[VASE] = -1
//	GOTO 9021
//
//C  SAY.  ECHO WD2 (OR WD1 IF NO WD2 (SAY WHAT?, ETC.) .)   MAGIC WORDS OVERRIDE.
//
//9030	CALL A5TOA1(WD2,WD2X,'".',TK,K) 
//	if (WD2 == 0) CALL A5TOA1(WD1,WD1X,'".',TK,K) 
//	if (WD2 ! =  0) WD1 = WD2
//	I = VOCAB(WD1,-1) 
//	if (I == 62 || I == 65 || I == 71 || I == 2025) GOTO 9035
//	TYPE 9032,(TK[I],I = 1,K) 
//9032	FORMAT(/' Okay, "',20A1) 
//	GOTO 2012
//
//9035	WD2 = 0
//	OBJ = 0
//	GOTO 2630
//
//C  LOCK, UNLOCK, NO OBJECT GIVEN.  ASSUME VARIOUS THINGS IF PRESENT.
//
//8040	SPK = 28
//	if (HERE(CLAM) ) OBJ = CLAM
//	if (HERE(OYSTER) ) OBJ = OYSTER
//	if (AT(DOOR) ) OBJ = DOOR
//	if (AT(GRATE) ) OBJ = GRATE
//	if (OBJ ! =  0 && HERE(CHAIN) ) GOTO 8000
//	if (HERE(CHAIN) ) OBJ = CHAIN
//	if (OBJ == 0) GOTO 2011
//
//C  LOCK, UNLOCK OBJECT.  SPECIAL STUFF FOR OPENING CLAM/OYSTER AND FOR CHAIN.
//
//9040	if (OBJ == CLAM || OBJ == OYSTER) GOTO 9046
//	if (OBJ == DOOR) SPK = 111
//	if (OBJ == DOOR && PROP[DOOR] == 1) SPK = 54
//	if (OBJ == CAGE) SPK = 32
//	if (OBJ == KEYS) SPK = 55
//	if (OBJ == GRATE || OBJ == CHAIN) SPK = 31
//	if (SPK ! =  31 ||  !HERE(KEYS) ) GOTO 2011
//	if (OBJ == CHAIN) GOTO 9048
//	if ( !CLOSNG) GOTO 9043
//	K = 130
//	if ( !PANIC) CLOCK2 = 15
//	PANIC =  true
//	GOTO 2010
//
//9043	K = 34+PROP[GRATE]
//	PROP[GRATE] = 1
//	if (VERB == LOCK) PROP[GRATE] = 0
//	K = K+2*PROP[GRATE]
//	GOTO 2010
//
//C  CLAM/OYSTER.
//9046	K = 0
//	if (OBJ == OYSTER) K = 1
//	SPK = 124+K
//	if (TOTING(OBJ) ) SPK = 120+K
//	if ( !TOTING(TRIDNT) ) SPK = 122+K
//	if (VERB == LOCK) SPK = 61
//	if (SPK ! =  124) GOTO 2011
//	CALL DSTROY(CLAM) 
//	CALL DROP(OYSTER,LOC) 
//	CALL DROP(PEARL,105) 
//	GOTO 2011
//
//C  CHAIN.
//9048	if (VERB == LOCK) GOTO 9049
//	SPK = 171
//	if (PROP[BEAR] == 0) SPK = 41
//	if (PROP[CHAIN] == 0) SPK = 37
//	if (SPK ! =  171) GOTO 2011
//	PROP[CHAIN] = 0
//	FIXED[CHAIN] = 0
//	if (PROP[BEAR] ! =  3) PROP[BEAR] = 2
//	FIXED[BEAR] = 2-PROP[BEAR]
//	GOTO 2011
//
//9049	SPK = 172
//	if (PROP[CHAIN] ! =  0) SPK = 34
//	if (LOC ! =  PLAC[CHAIN]) SPK = 173
//	if (SPK ! =  172) GOTO 2011
//	PROP[CHAIN] = 2
//	if (TOTING(CHAIN) ) CALL DROP(CHAIN,LOC) 
//	FIXED[CHAIN] = -1
//	GOTO 2011
//
//C  LIGHT LAMP
//
//9070	if ( !HERE(LAMP) ) GOTO 2011
//	SPK = 184
//	if (LIMIT < 0) GOTO 2011
//	PROP[LAMP] = 1
//	CALL RSPEAK(39) 
//	if (WZDARK) GOTO 2000
//	GOTO 2012
//
//C  LAMP OFF
//
//9080	if ( !HERE(LAMP) ) GOTO 2011
//	PROP[LAMP] = 0
//	CALL RSPEAK(40) 
//	if (DARK(0) ) CALL RSPEAK(16) 
//	GOTO 2012
//
//C  WAVE.  NO EFFECT UNLESS WAVING ROD AT FISSURE.
//
//9090	if (( !TOTING(OBJ) )  && (OBJ ! =  ROD ||  !TOTING(ROD2) ) ) 
//	1	SPK = 29
//	if (OBJ ! =  ROD ||  !AT(FISSUR)  ||  !TOTING(OBJ) 
//	1	 || CLOSNG) GOTO 2011
//	PROP[FISSUR] = 1-PROP[FISSUR]
//	CALL PSPEAK(FISSUR,2-PROP[FISSUR]) 
//	GOTO 2012
//
//C  ATTACK.  ASSUME TARGET IF UNAMBIGUOUS.  "THROW" ALSO LINKS HERE.  ATTACKABLE
//C  OBJECTS FALL INTO TWO CATEGORIES: ENEMIES (SNAKE, DWARF, ETC.)   AND OTHERS
//C  (BIRD, CLAM) .  AMBIGUOUS IF TWO ENEMIES, OR IF NO ENEMIES BUT TWO OTHERS.
//
//9120
	for (var I = 1; I <= 5; I++) {
			if (DLOC[I] == LOC && DFLAG >=  2) {}//GOTO 9122;
//9121	
			}
//	I = 0
//9122	if (OBJ ! =  0) GOTO 9124
//	if (I ! =  0) OBJ = DWARF
//	if (HERE(SNAKE) ) OBJ = OBJ*100+SNAKE
//	if (AT(DRAGON)  && PROP[DRAGON] == 0) OBJ = OBJ*100+DRAGON
//	if (AT(TROLL) ) OBJ = OBJ*100+TROLL
//	if (HERE(BEAR)  && PROP[BEAR] == 0) OBJ = OBJ*100+BEAR
//	if (OBJ > 100) GOTO 8000
//	if (OBJ ! =  0) GOTO 9124
//C  CAN'T ATTACK BIRD BY THROWING AXE.
//	if (HERE(BIRD)  && VERB ! =  THROW) OBJ = BIRD
//C  CLAM AND OYSTER BOTH TREATED AS CLAM FOR INTRANSITIVE CASE; NO HARM DONE.
//	if (HERE(CLAM)  || HERE(OYSTER) ) OBJ = 100*OBJ+CLAM
//	if (OBJ > 100) GOTO 8000
//9124	if (OBJ ! =  BIRD) GOTO 9125
//	SPK = 137
//	if (CLOSED) GOTO 2011
//	CALL DSTROY(BIRD) 
//	PROP[BIRD] = 0
//	if (PLACE[SNAKE] == PLAC[SNAKE]) TALLY2 = TALLY2+1
//	SPK = 45
//9125	if (OBJ == 0) SPK = 44
//	if (OBJ == CLAM || OBJ == OYSTER) SPK = 150
//	if (OBJ == SNAKE) SPK = 46
//	if (OBJ == DWARF) SPK = 49
//	if (OBJ == DWARF && CLOSED) GOTO 19000
//	if (OBJ == DRAGON) SPK = 167
//	if (OBJ == TROLL) SPK = 157
//	if (OBJ == BEAR) SPK = 165+(PROP[BEAR]+1) /2
//	if (OBJ ! =  DRAGON || PROP[DRAGON] ! =  0) GOTO 2011
//C  FUN STUFF FOR DRAGON.  IF HE INSISTS ON ATTACKING IT, WIN!  SET PROP TO DEAD,
//C  MOVE DRAGON TO CENTRAL LOC (STILL FIXED) , MOVE RUG THERE (NOT FIXED) , AND
//C  MOVE HIM THERE, TOO.  THEN DO A NULL MOTION TO GET NEW DESCRIPTION.
//	CALL RSPEAK(49) 
//	VERB = 0
//	OBJ = 0
//	CALL GETIN(WD1,WD1X,WD2,WD2X) 
//	if (WD1 ! =  'Y' && WD1 ! =  'YES') GOTO 2608
//	CALL PSPEAK(DRAGON,1) 
//	PROP[DRAGON] = 2
//	PROP[RUG] = 0
	var K = (PLAC[DRAGON]+FIXD[DRAGON]) /2;
//	CALL MOVE(DRAGON+100,-1) 
//	CALL MOVE(RUG+100,0) 
//	CALL MOVE(DRAGON,K) 
//	CALL MOVE(RUG,K) 
		for (var OBJ = 1; OBJ <= 100; OBJ++) { 
			IDONDX = OBJ;
			if (PLACE[IDONDX] == PLAC[DRAGON] || PLACE[IDONDX] == FIXD[DRAGON]) MOVE(IDONDX,K) ;
//9126
			}
//	LOC = K
//	K = NULL
//	GOTO 8
//
//C  POUR.  IF NO OBJECT, OR OBJECT IS BOTTLE, ASSUME CONTENTS OF BOTTLE.
//C  SPECIAL TESTS FOR POURING WATER OR OIL ON PLANT OR RUSTY DOOR.
//
//9130	if (OBJ == BOTTLE || OBJ == 0) OBJ = LIQ(0) 
//	if (OBJ == 0) GOTO 8000
//	if ( !TOTING(OBJ) ) GOTO 2011
//	SPK = 78
//	if (OBJ ! =  OIL && OBJ ! =  WATER) GOTO 2011
//	PROP[BOTTLE] = 1
//	PLACE[OBJ] = 0
//	SPK = 77
//	if ( !(AT(PLANT)  || AT(DOOR) ) ) GOTO 2011
//
//	if (AT(DOOR) ) GOTO 9132
//	SPK = 112
//	if (OBJ ! =  WATER) GOTO 2011
//	CALL PSPEAK(PLANT,PROP[PLANT]+1) 
//	PROP[PLANT] = PROP[PLANT]+2 % 6;
//	PROP[PLANT2] = PROP[PLANT]/2
//	K = NULL
//	GOTO 8
//
//9132	PROP[DOOR] = 0
//	if (OBJ == OIL) PROP[DOOR] = 1
//	SPK = 113+PROP[DOOR]
//	GOTO 2011
//
//C  EAT.  INTRANSITIVE: ASSUME FOOD IF PRESENT, ELSE ASK WHAT.  TRANSITIVE: FOOD
//C  OK, SOME THINGS LOSE APPETITE, REST ARE RIDICULOUS.
//
//8140	if ( !HERE(FOOD) ) GOTO 8000
//8142	CALL DSTROY(FOOD) 
//	SPK = 72
//	GOTO 2011
//
//9140	if (OBJ == FOOD) GOTO 8142
//	if (OBJ == BIRD || OBJ == SNAKE || OBJ == CLAM || OBJ == OYSTER
//	1	 || OBJ == DWARF || OBJ == DRAGON || OBJ == TROLL
//	2	 || OBJ == BEAR) SPK = 71
//	GOTO 2011
//
//C  DRINK.  IF NO OBJECT, ASSUME WATER AND LOOK FOR IT HERE.  IF WATER IS IN
//C  THE BOTTLE, DRINK THAT, ELSE MUST BE AT A WATER LOC, SO DRINK STREAM.
//
//9150	if (OBJ == 0 && LIQLOC(LOC)  ! =  WATER && (LIQ(0)  ! =  WATER
//	1	 ||  !HERE(BOTTLE) ) ) GOTO 8000
//	if (OBJ ! =  0 && OBJ ! =  WATER) SPK = 110
//	if (SPK == 110 || LIQ(0)  ! =  WATER ||  !HERE(BOTTLE) ) GOTO 2011
//	PROP[BOTTLE] = 1
//	PLACE[WATER] = 0
//	SPK = 74
//	GOTO 2011
//
//C  RUB.  YIELDS VARIOUS SNIDE REMARKS.
//
//9160	if (OBJ ! =  LAMP) SPK = 76
//	GOTO 2011
//
//C  THROW.  SAME AS DISCARD UNLESS AXE.  THEN SAME AS ATTACK EXCEPT IGNORE BIRD,
//C  AND IF DWARF IS PRESENT THEN ONE MIGHT BE KILLED.  (ONLY WAY TO DO SO!) 
//C  AXE ALSO SPECIAL FOR DRAGON, BEAR, AND TROLL.  TREASURES SPECIAL FOR TROLL.
//
//9170	if (TOTING(ROD2)  && OBJ == ROD &&  !TOTING(ROD) ) OBJ = ROD2
//	if ( !TOTING(OBJ) ) GOTO 2011
//	if (OBJ >=  50 && OBJ <=  MAXTRS && AT(TROLL) ) GOTO 9178
//	if (OBJ == FOOD && HERE(BEAR) ) GOTO 9177
//	if (OBJ ! =  AXE) GOTO 9020
	for (var I = 1; I <= 5; I++) {
		//  NEEDN'T CHECK DFLAG IF AXE IS HERE.
			if (DLOC[I] == LOC) {};//GOTO 9172;
//9171	
			}
//	SPK = 152
//	if (AT(DRAGON)  && PROP[DRAGON] == 0) GOTO 9175
//	SPK = 158
//	if (AT(TROLL) ) GOTO 9175
//	if (HERE(BEAR)  && PROP[BEAR] == 0) GOTO 9176
//	OBJ = 0
//	GOTO 9120
//
//9172	SPK = 48
//C  IF SAVED NOT  =  -1, HE BYPASSED THE "START" CALL.
//	if (RAN(3)  == 0 || SAVED ! =  -1) GOTO 9175
//	DSEEN[I] =  false
//	DLOC[I] = 0
//	SPK = 47
//	DKILL = DKILL+1
//	if (DKILL == 1) SPK = 149
//9175	CALL RSPEAK(SPK) 
//	CALL DROP(AXE,LOC) 
//	K = NULL
//	GOTO 8
//
//C  THIS'LL TEACH HIM TO THROW THE AXE AT THE BEAR!
//9176	SPK = 164
//	CALL DROP(AXE,LOC) 
//	FIXED[AXE] = -1
//	PROP[AXE] = 1
//	CALL JUGGLE(BEAR) 
//	GOTO 2011
//
//C  BUT THROWING FOOD IS ANOTHER STORY.
//9177	OBJ = BEAR
//	GOTO 9210
//
//9178	SPK = 159
//C  SNARF A TREASURE FOR THE TROLL.
//	CALL DROP(OBJ,0) 
//	CALL MOVE(TROLL,0) 
//	CALL MOVE(TROLL+100,0) 
//	CALL DROP(TROLL2,PLAC[TROLL]) 
//	CALL DROP(TROLL2+100,FIXD[TROLL]) 
//	CALL JUGGLE(CHASM) 
//	GOTO 2011
//
//C  QUIT.  INTRANSITIVE ONLY.  VERIFY INTENT AND EXIT IF THAT'S WHAT HE WANTS.
//
//8180	GAVEUP = YES(22,54,54) 
//8185	if (GAVEUP) GOTO 20000
//	GOTO 2012
//
//C  FIND.  MIGHT BE CARRYING IT, OR IT MIGHT BE HERE.  ELSE GIVE CAVEAT.
//
//9190	if (AT(OBJ)  || (LIQ(0)  == OBJ && AT(BOTTLE) ) 
//	1	 || K == LIQLOC(LOC) ) SPK = 94
		for (var I = 1; I <= 5; I++) { 
//9192	
	if (DLOC[I] == LOC && DFLAG >=  2 && OBJ == DWARF) SPK = 94;
	}
//	if (CLOSED) SPK = 138
//	if (TOTING(OBJ) ) SPK = 24
//	GOTO 2011
//
//C  INVENTORY.  IF OBJECT, TREAT SAME AS FIND.  ELSE REPORT ON CURRENT BURDEN.
//
//8200	SPK = 98
		for (var I = 1; I <= 100; I++) {
//	IDONDX = I
//	if (IDONDX == BEAR ||  !TOTING(IDONDX) ) GOTO 8201
//	if (SPK == 98) CALL RSPEAK(99) 
//	BLKLIN =  false
//	CALL PSPEAK(IDONDX,-1) 
//	BLKLIN =  true
//	SPK = 0
//8201	
		}
//	if (TOTING(BEAR) ) SPK = 141
//	GOTO 2011
//
//C  FEED.  IF BIRD, NO SEED.  SNAKE, DRAGON, TROLL: QUIP.  IF DWARF, MAKE HIM
//C  MAD.  BEAR, SPECIAL.
//
//9210	if (OBJ ! =  BIRD) GOTO 9212
//	SPK = 100
//	GOTO 2011
//
//9212	if (OBJ ! =  SNAKE && OBJ ! =  DRAGON && OBJ ! =  TROLL) GOTO 9213
//	SPK = 102
//	if (OBJ == DRAGON && PROP[DRAGON] ! =  0) SPK = 110
//	if (OBJ == TROLL) SPK = 182
//	if (OBJ ! =  SNAKE || CLOSED ||  !HERE(BIRD) ) GOTO 2011
//	SPK = 101
//	CALL DSTROY(BIRD) 
//	PROP[BIRD] = 0
//	TALLY2 = TALLY2+1
//	GOTO 2011
//
//9213	if (OBJ ! =  DWARF) GOTO 9214
//	if ( !HERE(FOOD) ) GOTO 2011
//	SPK = 103
//	DFLAG = DFLAG+1
//	GOTO 2011
//
//9214	if (OBJ ! =  BEAR) GOTO 9215
//	if (PROP[BEAR] == 0) SPK = 102
//	if (PROP[BEAR] == 3) SPK = 110
//	if ( !HERE(FOOD) ) GOTO 2011
//	CALL DSTROY(FOOD) 
//	PROP[BEAR] = 1
//	FIXED[AXE] = 0
//	PROP[AXE] = 0
//	SPK = 168
//	GOTO 2011
//
//9215	SPK = 14
//	GOTO 2011
//
//C  FILL.  BOTTLE MUST BE EMPTY, AND SOME LIQUID AVAILABLE.  (VASE IS NASTY.) 
//
//9220	if (OBJ == VASE) GOTO 9222
//	if (OBJ ! =  0 && OBJ ! =  BOTTLE) GOTO 2011
//	if (OBJ == 0 &&  !HERE(BOTTLE) ) GOTO 8000
//	SPK = 107
//	if (LIQLOC(LOC)  == 0) SPK = 106
//	if (LIQ(0)  ! =  0) SPK = 105
//	if (SPK ! =  107) GOTO 2011
//	PROP[BOTTLE] = ()COND[LOC] % 4) /2*2
//	K = LIQ(0) 
//	if (TOTING(BOTTLE) ) PLACE[K] = -1
//	if (K == OIL) SPK = 108
//	GOTO 2011
//
//9222	SPK = 29
//	if (LIQLOC(LOC)  == 0) SPK = 144
//	if (LIQLOC(LOC)  == 0 ||  !TOTING(VASE) ) GOTO 2011
//	CALL RSPEAK(145) 
//	PROP[VASE] = 2
//	FIXED[VASE] = -1
//	GOTO 9024
//
//C  BLAST.  NO EFFECT UNLESS YOU'VE GOT DYNAMITE, WHICH IS A NEAT TRICK!
//
//9230	if (PROP[ROD2] < 0 ||  !CLOSED) GOTO 2011
//	BONUS = 133
//	if (LOC == 115) BONUS = 134
//	if (HERE(ROD2) ) BONUS = 135
//	CALL RSPEAK(BONUS) 
//	GOTO 20000
//
//C  SCORE.  GO TO SCORING SECTION, WHICH WILL RETURN TO 8241 IF SCORNG IS TRUE.
//
//8240	SCORNG =  true
//	GOTO 20000
//
//8241	SCORNG =  false
//	TYPE 8243,SCORE,MXSCOR
//8243	FORMAT(/' If you were to quit now, you would score',I4
//	1	,' out of a possible',I4,'.') 
//	GAVEUP = YES(143,54,54) 
//	GOTO 8185
//
//C  FEE FIE FOE FOO (AND FUM) .  ADVANCE TO NEXT STATE IF GIVEN IN PROPER ORDER.
//C  LOOK UP WD1 IN SECTION 3 OF VOCAB TO DETERMINE WHICH WORD WE'VE GOT.  LAST
//C  WORD ZIPS THE EGGS BACK TO THE GIANT ROOM (UNLESS ALREADY THERE) .
//
//8250	K = VOCAB(WD1,3) 
//	SPK = 42
//	if (FOOBAR == 1-K) GOTO 8252
//	if (FOOBAR ! =  0) SPK = 151
//	GOTO 2011
//
//8252	FOOBAR = K
//	if (K ! =  4) GOTO 2009
//	FOOBAR = 0
//	if (PLACE[EGGS] == PLAC[EGGS]
//	1	 || (TOTING(EGGS)  && LOC == PLAC[EGGS]) ) GOTO 2011
//C  BRING BACK TROLL IF WE STEAL THE EGGS BACK FROM HIM BEFORE CROSSING.
//	if (PLACE[EGGS] == 0 && PLACE[TROLL] == 0 && PROP[TROLL] == 0) 
//	1	PROP[TROLL] = 1
//	K = 2
//	if (HERE(EGGS) ) K = 1
//	if (LOC == PLAC[EGGS]) K = 0
//	CALL MOVE(EGGS,PLAC[EGGS]) 
//	CALL PSPEAK(EGGS,K) 
//	GOTO 2012
//
//C  BRIEF.  INTRANSITIVE ONLY.  SUPPRESS LONG DESCRIPTIONS AFTER FIRST TIME.
//
//8260	SPK = 156
//	ABBNUM = 10000
//	DETAIL = 3
//	GOTO 2011
//
//C  READ.  MAGAZINES IN DWARVISH, MESSAGE WE'VE SEEN, AND . . . OYSTER?
//
//8270	if (HERE(MAGZIN) ) OBJ = MAGZIN
//	if (HERE(TABLET) ) OBJ = OBJ*100+TABLET
//	if (HERE(MESSAG) ) OBJ = OBJ*100+MESSAG
//	if (CLOSED && TOTING(OYSTER) ) OBJ = OYSTER
//	if (OBJ > 100 || OBJ == 0 || DARK(0) ) GOTO 8000
//
//9270	if (DARK(0) ) GOTO 5190
//	if (OBJ == MAGZIN) SPK = 190
//	if (OBJ == TABLET) SPK = 196
//	if (OBJ == MESSAG) SPK = 191
//	if (OBJ == OYSTER && HINTED[2] && TOTING(OYSTER) ) SPK = 194
//	if (OBJ ! =  OYSTER || HINTED[2] ||  !TOTING(OYSTER) 
//	1	 ||  !CLOSED) GOTO 2011
//	HINTED[2] = YES(192,193,54) 
//	GOTO 2012
//
//C  BREAK.  ONLY WORKS FOR MIRROR IN REPOSITORY AND, OF COURSE, THE VASE.
//
//9280	if (OBJ == MIRROR) SPK = 148
//	if (OBJ == VASE && PROP[VASE] == 0) GOTO 9282
//	if (OBJ ! =  MIRROR ||  !CLOSED) GOTO 2011
//	CALL RSPEAK(197) 
//	GOTO 19000
//
//9282	SPK = 198
//	if (TOTING(VASE) ) CALL DROP(VASE,LOC) 
//	PROP[VASE] = 2
//	FIXED[VASE] = -1
//	GOTO 2011
//
//C  WAKE.  ONLY USE IS TO DISTURB THE DWARVES.
//
//9290	if (OBJ ! =  DWARF ||  !CLOSED) GOTO 2011
//	CALL RSPEAK(199) 
//	GOTO 19000
//
//C  SUSPEND.  OFFER TO EXIT LEAVING THINGS RESTARTABLE, BUT REQUIRING A DELAY
//C  BEFORE RESTARTING (SO CAN'T SAVE THE WORLD BEFORE TRYING SOMETHING RISKY) .
//C  UPON RESTARTING, SETUP = -1 CAUSES RETURN TO 8305 TO PICK UP AGAIN.
//
//8300	SPK = 201
//	if (DEMO) GOTO 2011
//	TYPE 8302,LATNCY
//8302	FORMAT(/' I can suspend your adventure for you so that you can',
//	1	' resume later, but'/' you will have to wait at least',
//	2	I3,' minutes before continuing.') 
//	if ( !YES(200,54,54) ) GOTO 2012
//	CALL DATIME(SAVED,SAVET) 
//	SETUP = -1
//	CALL CIAO
//
//8305	YEA = START(0) 
//	SETUP = 3
//	K = NULL
//	GOTO 8
//
//C  HOURS.  REPORT CURRENT NON-PRIME-TIME HOURS.
//
//8310	CALL MSPEAK(6) 
//	CALL HOURS
//	GOTO 2012
//C  HINTS
//
//C  COME HERE IF HE'S BEEN LONG ENOUGH AT REQUIRED LOC(S)  FOR SOME UNUSED HINT.
//C  HINT NUMBER IS IN VARIABLE "HINT".  BRANCH TO QUICK TEST FOR ADDITIONAL
//C  CONDITIONS, THEN COME BACK TO DO NEAT STUFF.  GOTO 40010 IF CONDITIONS ARE
//C  MET AND WE WANT TO OFFER THE HINT.  GOTO 40020 TO CLEAR HINTLC BACK TO ZERO,
//C  40030 TO TAKE NO ACTION YET.
//
//40000	GOTO (40400,40500,40600,40700,40800,40900) (HINT-3) 
//C	      CAVE  BIRD  SNAKE MAZE  DARK  WITT
//	CALL BUG(27) 
//
//40010	HINTLC[HINT] = 0
//	if ( !YES(HINTS[HINT,3],0,54) ) GOTO 2602
//	TYPE 40012,HINTS[HINT,2]
//40012 FORMAT(/' I am prepared to give you a hint, but it will cost you',
//     1	I2,' points.') 
//	HINTED[HINT] = YES(175,HINTS[HINT,4],54) 
//	if (HINTED[HINT] && LIMIT > 30) LIMIT = LIMIT+30*HINTS[HINT,2]
//40020	HINTLC[HINT] = 0
//40030	GOTO 2602
//
//C  NOW FOR THE QUICK TESTS.  SEE DATABASE DESCRIPTION FOR ONE-LINE NOTES.
//
//40400	if (PROP[GRATE] == 0 &&  !HERE(KEYS) ) GOTO 40010
//	GOTO 40020
//
//40500	if (HERE(BIRD)  && TOTING(ROD)  && OBJ == BIRD) GOTO 40010
//	GOTO 40030
//
//40600	if (HERE(SNAKE)  &&  !HERE(BIRD) ) GOTO 40010
//	GOTO 40020
//
//40700	if (ATLOC[LOC] == 0 && ATLOC[OLDLOC] == 0
//	1	 && ATLOC[OLDLC2] == 0 && HOLDNG > 1) GOTO 40010
//	GOTO 40020
//
//40800	if (PROP[EMRALD] ! =  -1 && PROP[PYRAM] == -1) GOTO 40010
//	GOTO 40020
//
//40900	GOTO 40010
//C  CAVE CLOSING AND SCORING
//
//
//C  THESE SECTIONS HANDLE THE CLOSING OF THE CAVE.  THE CAVE CLOSES "CLOCK1"
//C  TURNS AFTER THE LAST TREASURE HAS BEEN LOCATED (INCLUDING THE PIRATE'S
//C  CHEST, WHICH MAY OF COURSE NEVER SHOW UP) .  NOTE THAT THE TREASURES NEED NOT
//C  HAVE BEEN TAKEN YET, JUST LOCATED.  HENCE CLOCK1 MUST BE LARGE ENOUGH TO GET
//C  OUT OF THE CAVE (IT ONLY TICKS WHILE INSIDE THE CAVE) .  WHEN IT HITS ZERO,
//C  WE BRANCH TO 10000 TO START CLOSING THE CAVE, AND THEN SIT BACK AND WAIT FOR
//C  HIM TO TRY TO GET OUT.  IF HE DOESN'T WITHIN CLOCK2 TURNS, WE CLOSE THE
//C  CAVE; IF HE DOES TRY, WE ASSUME HE PANICS, AND GIVE HIM A FEW ADDITIONAL
//C  TURNS TO GET FRANTIC BEFORE WE CLOSE.  WHEN CLOCK2 HITS ZERO, WE BRANCH TO
//C  11000 TO TRANSPORT HIM INTO THE FINAL PUZZLE.  NOTE THAT THE PUZZLE DEPENDS
//C  UPON ALL SORTS OF RANDOM THINGS.  FOR INSTANCE, THERE MUST BE NO WATER OR
//C  OIL, SINCE THERE ARE BEANSTALKS WHICH WE DON'T WANT TO BE ABLE TO WATER,
//C  SINCE THE CODE CAN'T HANDLE IT.  ALSO, WE CAN HAVE NO KEYS, SINCE THERE IS A
//C  GRATE (HAVING MOVED THE FIXED OBJECT!)  THERE SEPARATING HIM FROM ALL THE
//C  TREASURES.  MOST OF THESE PROBLEMS ARISE FROM THE USE OF NEGATIVE PROP
//C  NUMBERS TO SUPPRESS THE OBJECT DESCRIPTIONS UNTIL HE'S ACTUALLY MOVED THE
//C  OBJECTS.
//
//C  WHEN THE FIRST WARNING COMES, WE LOCK THE GRATE, DESTROY THE BRIDGE, KILL
//C  ALL THE DWARVES (AND THE PIRATE) , REMOVE THE TROLL AND BEAR (UNLESS DEAD) ,
//C  AND SET "CLOSNG" TO TRUE.  LEAVE THE DRAGON; TOO MUCH TROUBLE TO MOVE IT.
//C  FROM NOW UNTIL CLOCK2 RUNS OUT, HE CANNOT UNLOCK THE GRATE, MOVE TO ANY
//C  LOCATION OUTSIDE THE CAVE (LOC<9) , OR CREATE THE BRIDGE.  NOR CAN HE BE
//C  RESURRECTED IF HE DIES.  NOTE THAT THE SNAKE IS ALREADY GONE, SINCE HE GOT
//C  TO THE TREASURE ACCESSIBLE ONLY VIA THE HALL OF THE MT. KING.  ALSO, HE'S
//C  BEEN IN GIANT ROOM (TO GET EGGS) , SO WE CAN REFER TO IT.  ALSO ALSO, HE'S
//C  GOTTEN THE PEARL, SO WE KNOW THE BIVALVE IS AN OYSTER.  *AND*, THE DWARVES
//C  MUST HAVE BEEN ACTIVATED, SINCE WE'VE FOUND CHEST.
//
//10000	PROP[GRATE] = 0
//	PROP[FISSUR] = 0
		for (var I = 1; I <= 6; I++) { 
			DSEEN[I] =  false;
//10010
			DLOC[I] = 0; }
//	CALL MOVE(TROLL,0) 
//	CALL MOVE(TROLL+100,0) 
//	CALL MOVE(TROLL2,PLAC[TROLL]) 
//	CALL MOVE(TROLL2+100,FIXD[TROLL]) 
//	CALL JUGGLE(CHASM) 
//	if (PROP[BEAR] ! =  3) CALL DSTROY(BEAR) 
//	PROP[CHAIN] = 0
//	FIXED[CHAIN] = 0
//	PROP[AXE] = 0
//	FIXED[AXE] = 0
//	CALL RSPEAK(129) 
//	CLOCK1 = -1
//	CLOSNG =  true
//	GOTO 19999
//
//C  ONCE HE'S PANICKED, AND CLOCK2 HAS RUN OUT, WE COME HERE TO SET UP THE
//C  STORAGE ROOM.  THE ROOM HAS TWO LOCS, HARDWIRED AS 115 (NE)  AND 116 (SW) .
//C  AT THE NE END, WE PLACE EMPTY BOTTLES, A NURSERY OF PLANTS, A BED OF
//C  OYSTERS, A PILE OF LAMPS, RODS WITH STARS, SLEEPING DWARVES, AND HIM.  AND
//C  THE SW END WE PLACE GRATE OVER TREASURES, SNAKE PIT, COVEY OF CAGED BIRDS,
//C  MORE RODS, AND PILLOWS.  A MIRROR STRETCHES ACROSS ONE WALL.  MANY OF THE
//C  OBJECTS COME FROM KNOWN LOCATIONS AND/OR STATES (E.G. THE SNAKE IS KNOWN TO
//C  HAVE BEEN DESTROYED AND NEEDN'T BE CARRIED AWAY FROM ITS OLD "PLACE") ,
//C  MAKING THE VARIOUS OBJECTS BE HANDLED DIFFERENTLY.  WE ALSO DROP ALL OTHER
//C  OBJECTS HE MIGHT BE CARRYING (LEST HE HAVE SOME WHICH COULD CAUSE TROUBLE,
//C  SUCH AS THE KEYS) .  WE DESCRIBE THE FLASH OF LIGHT AND TRUNDLE BACK.
//
//11000	PROP[BOTTLE] = PUT(BOTTLE,115,1) 
//	PROP[PLANT] = PUT(PLANT,115,0) 
//	PROP[OYSTER] = PUT(OYSTER,115,0) 
//	PROP[LAMP] = PUT(LAMP,115,0) 
//	PROP[ROD] = PUT(ROD,115,0) 
//	PROP[DWARF] = PUT(DWARF,115,0) 
//	LOC = 115
//	OLDLOC = 115
//	NEWLOC = 115
//
//C  LEAVE THE GRATE WITH NORMAL (NON-NEGATIVE PROPERTY) .
//
//	FOO = PUT(GRATE,116,0) 
//	PROP[SNAKE] = PUT(SNAKE,116,1) 
//	PROP[BIRD] = PUT(BIRD,116,1) 
//	PROP[CAGE] = PUT(CAGE,116,0) 
//	PROP[ROD2] = PUT(ROD2,116,0) 
//	PROP[PILLOW] = PUT(PILLOW,116,0) 
//
//	PROP[MIRROR] = PUT(MIRROR,115,0) 
//	FIXED[MIRROR] = 116
//
		for (var I = 1; I <= 100; I++) {
			IDONDX = I;
//11010
			if (TOTING(IDONDX) ) DSTROY(IDONDX); }
//
//	CALL RSPEAK(132) 
//	CLOSED =  true
//	GOTO 2
//
//C  ANOTHER WAY WE CAN FORCE AN END TO THINGS IS BY HAVING THE LAMP GIVE OUT.
//C  WHEN IT GETS CLOSE, WE COME HERE TO WARN HIM.  WE GO TO 12000 IF THE LAMP
//C  AND FRESH BATTERIES ARE HERE, IN WHICH CASE WE REPLACE THE BATTERIES AND
//C  CONTINUE.  12200 IS FOR OTHER CASES OF LAMP DYING.  12400 IS WHEN IT GOES
//C  OUT, AND 12600 IS IF HE'S WANDERED OUTSIDE AND THE LAMP IS USED UP, IN WHICH
//C  CASE WE FORCE HIM TO GIVE UP.
//
//12000	CALL RSPEAK(188) 
//	PROP[BATTER] = 1
//	if (TOTING(BATTER) ) CALL DROP(BATTER,LOC) 
//	LIMIT = LIMIT+2500
//	LMWARN =  false
//	GOTO 19999
//
//12200	if (LMWARN ||  !HERE(LAMP) ) GOTO 19999
//	LMWARN =  true
//	SPK = 187
//	if (PLACE[BATTER] == 0) SPK = 183
//	if (PROP[BATTER] == 1) SPK = 189
//	CALL RSPEAK(SPK) 
//	GOTO 19999
//
//12400	LIMIT = -1
//	PROP[LAMP] = 0
//	if (HERE(LAMP) ) CALL RSPEAK(184) 
//	GOTO 19999
//
//12600	CALL RSPEAK(185) 
//	GAVEUP =  true
//	GOTO 20000
//
//C  AND, OF COURSE, DEMO GAMES ARE ENDED BY THE WIZARD.
//
//13000	CALL MSPEAK(1) 
//	GOTO 20000
//
//C  OH DEAR, HE'S DISTURBED THE DWARVES.
//
//19000	CALL RSPEAK(136) 
//
//C  EXIT CODE.  WILL EVENTUALLY INCLUDE SCORING.  FOR NOW, HOWEVER, ...
//
//C  THE PRESENT SCORING ALGORITHM IS AS FOLLOWS:
//C     OBJECTIVE:          POINTS:        PRESENT TOTAL POSSIBLE:
//C  GETTING WELL INTO CAVE   25                    25
//C  EACH TREASURE < CHEST    12                    60
//C  TREASURE CHEST ITSELF    14                    14
//C  EACH TREASURE > CHEST    16                   144
//C  SURVIVING             (MAX-NUM) *10             30
//C  NOT QUITTING              4                     4
//C  REACHING "CLOSNG"        25                    25
//C  "CLOSED": QUIT/KILLED    10
//C            KLUTZED        25
//C            WRONG WAY      30
//C            SUCCESS        45                    45
//C  CAME TO WITT'S END        1                     1
//C  ROUND OUT THE TOTAL       2                     2
//C                                       TOTAL:   350
//C  (POINTS CAN ALSO BE DEDUCTED FOR USING HINTS.) 
//
//20000	SCORE = 0
//	MXSCOR = 0
//
//C  FIRST TALLY UP THE TREASURES.  MUST BE IN BUILDING AND NOT BROKEN.
//C  GIVE THE POOR GUY 2 POINTS JUST FOR FINDING EACH TREASURE.
//
		for (var I = 50; I <= MAXTRS; I++) { 
			if (PTEXT[I] == 0) {}//GOTO 20010;
			K = 12;
			if (I == CHEST) K = 14;
			if (I > CHEST) K = 16;
			if (PROP[I] >=  0) SCORE = SCORE+2;
			if (PLACE[I] == 3 && PROP[I] == 0) SCORE = SCORE+K-2;
			MXSCOR = MXSCOR+K;
//20010	
			}
//
//C  NOW LOOK AT HOW HE FINISHED AND HOW FAR HE GOT.  MAXDIE AND NUMDIE TELL US
//C  HOW WELL HE SURVIVED.  GAVEUP SAYS WHETHER HE EXITED VIA QUIT.  DFLAG WILL
//C  TELL US IF HE EVER GOT SUITABLY DEEP INTO THE CAVE.  CLOSNG STILL INDICATES
//C  WHETHER HE REACHED THE ENDGAME.  AND IF HE GOT AS FAR AS "CAVE CLOSED"
//C  (INDICATED BY "CLOSED") , THEN BONUS IS ZERO FOR MUNDANE EXITS OR 133, 134,
//C  135 IF HE BLEW IT (SO TO SPEAK) .
//
//	SCORE = SCORE+(MAXDIE-NUMDIE) *10
//	MXSCOR = MXSCOR+MAXDIE*10
//	if ( !(SCORNG || GAVEUP) ) SCORE = SCORE+4
//	MXSCOR = MXSCOR+4
//	if (DFLAG ! =  0) SCORE = SCORE+25
//	MXSCOR = MXSCOR+25
//	if (CLOSNG) SCORE = SCORE+25
//	MXSCOR = MXSCOR+25
//	if ( !CLOSED) GOTO 20020
//	if (BONUS == 0) SCORE = SCORE+10
//	if (BONUS == 135) SCORE = SCORE+25
//	if (BONUS == 134) SCORE = SCORE+30
//	if (BONUS == 133) SCORE = SCORE+45
//20020	MXSCOR = MXSCOR+45
//
//C  DID HE COME TO WITT'S END AS HE SHOULD?
//
//	if (PLACE[MAGZIN] == 108) SCORE = SCORE+1
//	MXSCOR = MXSCOR+1
//
//C  ROUND IT OFF.
//
//	SCORE = SCORE+2
//	MXSCOR = MXSCOR+2
//
//C  DEDUCT POINTS FOR HINTS.  HINTS < 4 ARE SPECIAL; SEE DATABASE DESCRIPTION.
//
		for (var I = 1; I <= HNTMAX; I++) { 
//20030
			if (HINTED[I]) SCORE = SCORE-HINTS[I,2]; }
//
//C  RETURN TO SCORE COMMAND IF THAT'S WHERE WE CAME FROM.
//
//	if (SCORNG) GOTO 8241
//
//C  THAT SHOULD BE GOOD ENOUGH.  LET'S TELL HIM ALL ABOUT IT.
//
//	TYPE 20100,SCORE,MXSCOR,TURNS
//20100	FORMAT(///' You scored',I4,' out of a possible',I4,
//	1	', using',I5,' turns.') 
//
	for (var I = 1; I <= CLSSES; I++) { 
		if (CVAL[I] >=  SCORE) {}; //GOTO 20210;
	}
//	TYPE 20202
//20202	FORMAT(/' You just went off my scale!!'/) 
//	GOTO 25000
//
//20210	CALL SPEAK(CTEXT[I]) 
//	if (I == CLSSES-1) GOTO 20220
//	K = CVAL[I]+1-SCORE
//	KK = 's.'
//	if (K == 1) KK = '. '
//	TYPE 20212,K,KK
//20212	FORMAT(/' To achieve the next higher rating, you need',I3,
//	1	' more point',A2/) 
//	GOTO 25000
//
//20220	TYPE 20222
//20222	FORMAT(/' To achieve the next higher rating ',
//	1	'would be a neat trick!'//' Congratulations!!'/) 
//
//25000	STOP
//
//
//	END

// I/O ROUTINES (SPEAK, PSPEAK, RSPEAK, GETIN, YES, A5TOA1)

// PRINT THE MESSAGE WHICH STARTS AT LINES(N).  PRECEDE IT WITH A BLANK LINE
// UNLESS BLKLIN IS FALSE.
// screen: indicates direct write to screen 
function SPEAK(n) { /** retest **/
	if (n == 0) return '';
	if (LINES[n].substr(8,3) == '>$<') return '';
	var mssg = '';
	var k = n;
	if (BLKLIN) out('');
	while (parseInt(LINES[k]) == parseInt(LINES[n])) {
		out(LINES[k].substr(8)); 
		mssg += LINES[k].substr(8);
		k++;
	}
	return mssg;
}

//FIND THE SKIP+1ST MESSAGE FROM MSG AND PRINT IT.  MSG SHOULD BE THE INDEX OF
//THE INVENTORY MESSAGE FOR OBJECT.  (INVEN+N+1 MESSAGE IS PROP=N MESSAGE).
function PSPEAK(msg, skip) {
	var m = PTEXT[msg];
	if (skip >= 0) m += skip + 1;
	return SPEAK(m);
}

//PRINT THE I-TH "RANDOM" MESSAGE (SECTION 6 OF DATABASE).
function RSPEAK(i) {
	if (i != 0) return SPEAK(RTEXT[i]);
	else return '';
}

//PRINT THE I-TH "MAGIC" MESSAGE (SECTION 12 OF DATABASE).
function MSPEAK(i) {
	if (i != 0) return SPEAK(MTEXT[i]);
	else return '';
}

/*
		SUBROUTINE GETIN(WORD1,WORD1X,WORD2,WORD2X)

	// GET A COMMAND FROM THE ADVENTURER.  SNARF OUT THE FIRST WORD, PAD IT WITH
	// BLANKS, AND RETURN IT IN WORD1.  CHARS 6 THRU 10 ARE RETURNED IN WORD1X, IN
	// CASE WE NEED TO PRINT OUT THE WHOLE WORD IN AN ERROR MESSAGE.  ANY NUMBER OF
	// BLANKS MAY FOLLOW THE WORD.  IF A SECOND WORD APPEARS, IT IS RETURNED IN
	// WORD2 (CHARS 6 THRU 10 IN WORD2X), ELSE WORD2 IS SET TO ZERO.
	var GETIN = function(WORD1,WORD1X,WORD2,WORD2X) {
		
	};
		DIMENSION A(5),MASKS(6)
		DATA MASKS/"4000000000,"20000000,"100000,"400,"2,0/
		1	,BLANKS/'     '/

		IF(BLKLIN)TYPE 1
	1	FORMAT()
	2	ACCEPT 3,(A(I),I=1,4)
	3	FORMAT(4A5)
		J=0
		DO 9 I=1,4
		IF(A(I).NE.BLANKS)J=1
	9	A(I)=A(I).AND.(SHIFT((A(I).AND.'@@@@@'),-1).XOR.-1)
		IF(BLKLIN.AND.J.EQ.0)GOTO 2

		SECOND=0
		WORD1=A(1)
		WORD1X=A(2)
		WORD2=0

		DO 10 J=1,4
		DO 10 K=1,5
		MSK="774000000000
		IF(K.NE.1)MSK="177*MASKS(K)
		IF(((A(J).XOR.BLANKS).AND.MSK).EQ.0)GOTO 15
		IF(SECOND.EQ.0)GOTO 10
		MSK=-MASKS(6-K)
		WORD2=(SHIFT(A(J),7*(K-1)).AND.MSK)
		1	+(SHIFT(A(J+1),7*(K-6)).AND.(-2-MSK))
		WORD2X=(SHIFT(A(J+1),7*(K-1)).AND.MSK)
		1	+(SHIFT(A(J+2),7*(K-6)).AND.(-2-MSK))
		RETURN

	15	IF(SECOND.EQ.1)GOTO 10
		SECOND=1
		IF(J.EQ.1)WORD1=(WORD1.AND.-MASKS(K))
		1	.OR.(BLANKS.AND.(-MASKS(K).XOR.-1))
	10	CONTINUE
		RETURN
		END
*/


//CALL YESX (BELOW) WITH MESSAGES FROM SECTION 6.
function YES(x, y, z) { /** as this is the only one pointing to YESX, it can be incorporated **/
	return YESX(x, y, z, RSPEAK);
}

//CALL YESX (BELOW) WITH MESSAGES FROM SECTION 12.
function YESM(x, y, z) { /** won't happen **/
	return YESX(x, y, z, MSPEAK);
}

// PRINT MESSAGE X, WAIT FOR YES/NO ANSWER.  IF YES, PRINT Y AND LEAVE YEA
// TRUE; IF NO, PRINT Z AND LEAVE YEA FALSE.  SPK IS EITHER RSPEAK OR MSPEAK.
function YESX(x, y, z, spk) {
	var reply = false;
	if (x != 0) {
		reply = confirm(spk(x));
		if (reply) { out('> Yes'); spk(y); }
		else { out('> No'); spk(z); }
	}
	return reply;
}

// SUBROUTINE A5TOA1(A,B,C,CHARS,LENG) - no need for unpacking characters

// A AND B CONTAIN A 1- TO 9-CHARACTER WORD IN A5 FORMAT, C CONTAINS ANOTHER
// WORD AND/OR PUNCTUATION.  THEY ARE UNPACKED TO ONE CHARACTER PER WORD IN THE
// ARRAY "CHARS", WITH EXACTLY ONE BLANK BETWEEN B AND C (OR NONE, IF C >= 0).
// THE INDEX OF THE LAST NON-BLANK CHAR IN CHARS IS RETURNED IN LENG.
function A5TOA1(A,B,C,CHARS,LENG) {
	return;
}
/*
	    IMPLICIT INTEGER(A-Z)
		DIMENSION CHARS(20),WORDS(3)
		DATA MASK,BLANK/"774000000000,' '/

		WORDS(1)=A
		WORDS(2)=B
		WORDS(3)=C
		POSN=1
		DO 1 WORD=1,3
		IF(WORD.EQ.2.AND.POSN.NE.6)GOTO 1
		IF(WORD.EQ.3.AND.C.LT.0)POSN=POSN+1
		DO 2 CH=1,5
		CHARS(POSN)=(WORDS(WORD).AND.MASK)+(BLANK-(BLANK.AND.MASK))
		IF(CHARS(POSN).EQ.BLANK)GOTO 1
		LENG=POSN
		WORDS(WORD)=SHIFT(WORDS(WORD),7)
	2	POSN=POSN+1
	1	CONTINUE
		RETURN
		END
*/

// DATA STRUCTURE ROUTINES (VOCAB, DSTROY, JUGGLE, MOVE, PUT, CARRY, DROP)

// LOOK UP ID IN THE VOCABULARY (ATAB) AND RETURN ITS "DEFINITION" (KTAB), OR
// -1 IF NOT FOUND.  IF INIT IS POSITIVE, THIS IS AN INITIALISATION CALL SETTING
// UP A KEYWORD VARIABLE, AND NOT FINDING IT CONSTITUTES A BUG.  IT ALSO MEANS
// THAT ONLY KTAB VALUES WHICH TAKEN OVER 1000 EQUAL INIT MAY BE CONSIDERED.
// (THUS "STEPS", WHICH IS A MOTION VERB AS WELL AS AN OBJECT, MAY BE LOCATED
// AS AN OBJECT.)  AND IT ALSO MEANS THE KTAB VALUE IS TAKEN MOD 1000.
function VOCAB(id, init) {
	for (var i = 1; i <= TABSIZ; i++) {
		if (KTAB[i] == -1) {
			if (init < 0) return -1; else throw 'REQUIRED VOCABULARY WORD NOT FOUND';
		}
		if (init >= 0 && (KTAB[i]/1000>>0) != init) continue;
		if (ATAB[i] == id) {
			if (init < 0) return KTAB[i];
			else return KTAB[i] % 1000;
		}
	}
	throw 'RAN OFF END OF VOCABULARY TABLE';
}
 
// PERMANENTLY ELIMINATE "OBJECT" BY MOVING TO A NON-EXISTENT LOCATION.
function DSTROY(object) {
	MOVE(object,0);
};

// JUGGLE AN OBJECT BY PICKING IT UP AND PUTTING IT DOWN AGAIN, THE PURPOSE
// BEING TO GET THE OBJECT TO THE FRONT OF THE CHAIN OF THINGS AT ITS LOC.
function JUGGLE(object) {
	var i = PLACE[object];
	var j = FIXED[object];
	MOVE(object, i);
	MOVE(object + 100, j);
}

// PLACE ANY OBJECT ANYWHERE BY PICKING IT UP AND DROPPING IT.  MAY ALREADY BE
// TOTING, IN WHICH CASE THE CARRY IS A NO-OP.  MUSTN'T PICK UP OBJECTS WHICH
// ARE NOT AT ANY LOC, SINCE CARRY WANTS TO REMOVE OBJECTS FROM ATLOC CHAINS.
function MOVE(object, where) {
	var from;
	if (object > 100) from = FIXED[object - 100];
	else from = PLACE[object];
	if (from > 0 && from <= 300) CARRY(object, from);
	DROP(object, where);
}

// PUT IS THE SAME AS MOVE, EXCEPT IT RETURNS A VALUE USED TO SET UP THE
// NEGATED PROP VALUES FOR THE REPOSITORY OBJECTS.
function PUT(object, where, pval) {
	MOVE(object, where);
	return (-1) - pval;
}

// START TOTING AN OBJECT, REMOVING IT FROM THE LIST OF THINGS AT ITS FORMER
// LOCATION.  INCR HOLDNG UNLESS IT WAS ALREADY BEING TOTED.  IF OBJECT>100
// (MOVING "FIXED" SECOND LOC), DON'T CHANGE PLACE OR HOLDNG.
function CARRY(object, where) {
	if (object <= 100 && PLACE[object] != -1) {
		PLACE[object] = -1;
		HOLDNG++;
	}
	if (ATLOC[where] == object) ATLOC[where] = LINK[object];
	else {
		var temp = ATLOC[where];
		while (LINK[temp] != object) temp = LINK[temp];
		LINK[temp] = LINK[object];
	}

}

// PLACE AN OBJECT AT A GIVEN LOC, PREFIXING IT ONTO THE ATLOC LIST.  DECR
// HOLDNG IF THE OBJECT WAS BEING TOTED.
function DROP(object, where) {
	if (object > 100) FIXED[object - 100] = where;
	else {
		if (PLACE[object] == -1) HOLDNG--;
		PLACE[object] = where;
	}
	if (where > 0) {
		LINK[object] = ATLOC[where];
		ATLOC[where] = object;
	}
}
		
// WIZARDRY ROUTINES (START, MAINT, WIZARD, HOURS(X), NEWHRS(X), MOTD, POOF)
// Skip these alltogether
function START() {};
function MAINT() {};
function WIZARD() {return false;};
function HOURS() {return;};
function NEWHRS() {return;};
function MOTD(alter) {return;};
function POOF() {
	WKDAY='00777400';
	WKEND=0;
	HOLID=0;
	HBEGIN=0;
	HEND=-1;
	SHORT=30;
	MAGIC='DWARF';
	MAGNM=11111;
	LATNCY=90;
}

// UTILITY ROUTINES (SHIFT, RAN, DATIME, CIAO, BUG)
// No real need ...

// RETURN VAL LEFT-SHIFTED (LOGICALLY) DIST BITS (RIGHT-SHIFT IF DIST<0).
function SHIFT(val, dist) {
	if (dist >= 0) return (val << dist);
	else return (val >> Math.abs(dist));
}

// RAN RETURNS A VALUE UNIFORMLY SELECTED BETWEEN 0 AND RANGE-1. 
function RAN(range) {
	return (range * Math.random())>>0; // right shift 0 to make this integer (alt. Math.floor)
}

// RETURN THE DATE AND TIME IN D AND T. (won't because javascript won't modify d and t)
function DATIME(d, t) {
	return;
}

// EXITS, AFTER ISSUING REMINDER TO SAVE NEW CORE IMAGE. No core in javascript (typical mainframe behavior)
function CIAO() {
	throw 'Be sure to save your core-image...';
}

// THE FOLLOWING CONDITIONS ARE CURRENTLY CONSIDERED FATAL BUGS.  NUMBERS < 20
// ARE DETECTED WHILE READING THE DATABASE; THE OTHERS OCCUR AT "RUN TIME".
function BUG(num) {
	var mssg = '';
	switch (num) {
		case 0: mssg = 'MESSAGE LINE > 70 CHARACTERS'; break;
		case 1: mssg = 'NULL LINE IN MESSAGE'; break;
		case 2: mssg = 'TOO MANY WORDS OF MESSAGES'; break;
		case 3: mssg = 'TOO MANY TRAVEL OPTIONS'; break;
		case 4: mssg = 'TOO MANY VOCABULARY WORDS'; break;
		case 5: mssg = 'REQUIRED VOCABULARY WORD NOT FOUND'; break;
		case 6: mssg = 'TOO MANY RTEXT OR MTEXT MESSAGES'; break;
		case 7: mssg = 'TOO MANY HINTS'; break;
		case 8: mssg = 'LOCATION HAS COND BIT BEING SET TWICE'; break;
		case 9: mssg = 'INVALID SECTION NUMBER IN DATABASE'; break;
		case 20: mssg = 'SPECIAL TRAVEL (500>L>300) EXCEEDS GOTO LIST'; break;
		case 21: mssg = 'RAN OFF END OF VOCABULARY TABLE'; break;
		case 22: mssg = 'VOCABULARY TYPE (N/1000) NOT BETWEEN 0 AND 3'; break;
		case 23: mssg = 'INTRANSITIVE ACTION VERB EXCEEDS GOTO LIST'; break;
		case 24: mssg = 'TRANSITIVE ACTION VERB EXCEEDS GOTO LIST'; break;
		case 25: mssg = 'CONDITIONAL TRAVEL ENTRY WITH NO ALTERNATIVE'; break;
		case 26: mssg = 'LOCATION HAS NO TRAVEL ENTRIES'; break;
		case 27: mssg = 'HINT NUMBER EXCEEDS GOTO LIST'; break;
		case 28: mssg = 'INVALID MONTH RETURNED BY DATE FUNCTION'; break;
	}
	throw 'Fatal error: ' + mssg;
}
